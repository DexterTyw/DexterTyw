{"meta":{"title":"Tyw_ei","subtitle":"For Our Future","description":"Gal Gadot","author":"by Dexter Yue","url":"https://dextertyw.github.io"},"pages":[{"title":"Links","date":"2017-07-24T07:40:46.160Z","updated":"2017-07-24T07:40:46.160Z","comments":true,"path":"Links/index.html","permalink":"https://dextertyw.github.io/Links/index.html","excerpt":"","text":"AnoxiacxyxljHeret1c"},{"title":"属性","date":"2017-07-24T06:21:19.989Z","updated":"2017-07-24T06:21:19.989Z","comments":true,"path":"About/index.html","permalink":"https://dextertyw.github.io/About/index.html","excerpt":"","text":"关于博主：基本1.一名学OI的菜鸟，由于不想学综合，在竞赛班苟着… 2.没有什么比较高远的目标，还是继续苟着 3.然后最重要的，不是二次元QAQ，Orz，挺喜欢Gal Gadot 4.处于幼年时期，如果有大佬不幸路过，别d.Orz 日常1.被同组的XXX各种花式吊打，心服口服 2.求同组的XXX带躺，QAQ 3.看Gal Gadot的ins，twitter…(颓废) 4.coc（垃圾7本） 一切都是为了将来，加油！"}],"posts":[{"title":"noip模拟赛2017.7.22","slug":"[noip模拟赛2017.7.22]","date":"2017-07-23T06:10:22.003Z","updated":"2017-07-24T07:20:22.937Z","comments":true,"path":"2017/07/23/[noip模拟赛2017.7.22]/","link":"","permalink":"https://dextertyw.github.io/2017/07/23/[noip模拟赛2017.7.22]/","excerpt":"【试题概览】 题目名称 数7 正方形计数 速算游戏 单人纸牌 提交文件 seven.* count.* fun.* double.* 输入文件 seven.in count.in fun.in double.in 输出文件 seven.out count.out fun.out double.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB","text":"【试题概览】 题目名称 数7 正方形计数 速算游戏 单人纸牌 提交文件 seven.* count.* fun.* double.* 输入文件 seven.in count.in fun.in double.in 输出文件 seven.out count.out fun.out double.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB 1. 数7【题目描述】1337 个人排成一个圈，从 1 号人开始报数，初始的方向是 1,2,3…。如果某个人报的数是 7 的倍数或 者数字中含有 7，那么报数的方向就反一下。问报数字 X 的是哪个人？ 【输入格式】一行一个数 X 【输出格式】一行一个数表示最终报数字 X 的是哪个人。 【数据规模】对于 30%的数据，满足 X&lt;=10^6;对于 90%的数据，满足 X&lt;=10^8;对于 100%的数据，满足 X&lt;=10^9。 【输入样例】1000 【输出样例】1311 Solution首先都想到了nlogn的做法，再想直接打表，如果打表的话估计也只能过10^8 ,而且还不稳定。先想想90分怎么做，考虑到主要的时间消耗在于对%7的判断以及对是否含有7的判断，与其取膜和分解判断，倒不如用个计数器和做类似于高精度加法（每次只加一复杂都有保证）.然后对于10^9只能间隔打表了。 2.正方形计数【题目描述】给定平面上 N 个点，你需要计算以其中 4 个点为顶点的正方形的个数。注意这里的正方形边不一定 需要和坐标轴平行。 【输入格式】第一行一个数 N 以下 N 个点的坐标。 【输出格式】一个数，表示正方形的个数 【数据规模】对于 20%的数据，满足 1&lt;=N&lt;=20;对于 100%的数据，满足 1&lt;=N&lt;=500，-50&lt;=x[i],y[i]&lt;=50，点不会重叠。 【输入样例】7 0 0 0 1 1 0 1 1 1 2 2 1 2 2 Solution暴力枚举正方形的四个顶点判断边是否相等即可。或者枚举两个定点根据条件判断另外两个点是否存在。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct node&#123; int x,y; friend bool operator &lt; (node a,node b)&#123; if(a.x==b.x)return a.y&lt;b.y; return a.x&lt;b.x; &#125;&#125;point[550];int n,ans;int work(int x1,int y1,int x2,int y2)&#123; return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);&#125;int main()&#123; freopen(\"count.in\",\"r\",stdin); freopen(\"count.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;point[i].x,&amp;point[i].y); sort(point+1,point+1+n); for(int i=1;i&lt;=n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; int line_1=work(point[i].x,point[i].y,point[j].x,point[j].y); if(!line_1)continue; for(int k=j+1;k&lt;=n;k++) &#123; int line_2=work(point[i].x,point[i].y,point[k].x,point[k].y); if(line_1!=line_2)continue; for(int p=k+1;p&lt;=n;p++) &#123; int line_3=work(point[k].x,point[k].y,point[p].x,point[p].y); int line_4=work(point[p].x,point[p].y,point[j].x,point[j].y); int line_5=work(point[i].x,point[i].y,point[p].x,point[p].y); int line_6=work(point[j].x,point[j].y,point[k].x,point[k].y); if(line_2==line_3&amp;&amp;line_3==line_4&amp;&amp;line_5==line_6) ans++; &#125; &#125; &#125; &#125; printf(\"%d\",ans); return 0;&#125;/*70 00 11 01 11 22 12 2*/ 【输出样例】3 3.速算游戏【题目描述】jyx 和 cyy 打赌，比谁 24 点算得快，算得慢的那个人请客。24 点的规则是这样的：给定 4个 1..9 的整数，用括号改变运算顺序，通过加、减、乘、除通的一系列运算，得到整数 24，注意所有中间结果必须是整数（例如(22)/4 是允许的，而 2(2/4)是不允许的）。为了赢得这个比赛，请写一个程序帮助我作弊，快速地计算出 24 点。 【输入格式】一行 4 个整数，为给定的 4 个数字。输入数据保证有解。 【输出格式】一行，以字符串的形式输出结果，注意将每一步的运算的括号补齐（例如(3+5)+6 和3*(5+6)）如果有多种解答，输出字典顺序最小的一个。 【输入样例】2357 【输出样例】(((3*5)+2)+7) Solution被括号给骗了 感觉这道题挺蛮麻烦的，时只有3.5小时,所幸没有做，后来题时，真是傻逼题。太弱了…..括号在这题里只会有三种情况，自己想一想，然后依次写三个暴力就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF -2147483647using namespace std;int n[5],now[10],vis[10],r[50];int num[50][5];int cnt,tot;char ans[50][100];char trs(int x)&#123; if(x==1)return '+'; if(x==2)return '-'; if(x==3)return '*'; if(x==4)return '/';&#125;void Dfs_Pai(int pos)&#123; if(pos==5) &#123; cnt++; for(int i=1;i&lt;=4;i++) num[cnt][i]=now[i]; &#125; for(int i=1;i&lt;=4;i++) &#123; if(!vis[i]) &#123; now[pos]=n[i]; vis[i]=true; Dfs_Pai(pos+1); vis[i]=false; &#125; &#125;&#125;int calu(int a,int b,int opt)&#123; if(opt==1)return a+b; if(opt==2)return a-b; if(opt==3)return a*b; if(opt==4&amp;&amp;b!=0&amp;&amp;a%b==0)return a/b; return -INF;&#125;void Dfs_Judge(int p)&#123; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][1],num[p][2],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(result_1,num[p][3],j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(result_2,num[p][4],k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]='('; ans[tot][2]='('; ans[tot][3]=num[p][1]+'0'; ans[tot][4]=trs(i); ans[tot][5]=num[p][2]+'0'; ans[tot][6]=')'; ans[tot][7]=trs(j); ans[tot][8]=num[p][3]+'0'; ans[tot][9]=')'; ans[tot][10]=trs(k); ans[tot][11]=num[p][4]+'0'; ans[tot][12]=')'; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][1],num[p][2],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(num[p][3],num[p][4],j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(result_1,result_2,k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]='('; ans[tot][2]=num[p][1]+'0'; ans[tot][3]=trs(i); ans[tot][4]=num[p][2]+'0'; ans[tot][5]=')'; ans[tot][6]=trs(k); ans[tot][7]='('; ans[tot][8]=num[p][3]+'0'; ans[tot][9]=trs(j); ans[tot][10]=num[p][4]+'0'; ans[tot][11]=')'; ans[tot][12]=')'; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][3],num[p][4],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(num[p][2],result_1,j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(num[p][1],result_2,k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]=num[p][1]+'0'; ans[tot][2]=trs(k); ans[tot][3]='('; ans[tot][4]=num[p][2]+'0'; ans[tot][5]=trs(j); ans[tot][6]='('; ans[tot][7]=num[p][3]+'0'; ans[tot][8]=trs(i); ans[tot][9]=num[p][4]+'0'; ans[tot][10]=')'; ans[tot][11]=')'; ans[tot][12]=')'; &#125; &#125; &#125; &#125;&#125;bool cmp(int x,int y)&#123; for(int i=1;i&lt;=13;i++) &#123; if(ans[x][i]==ans[y][i])continue; return ans[x][i]&lt;ans[y][i]; &#125;&#125;int main()&#123; freopen(\"fun.in\",\"r\",stdin); freopen(\"fun.out\",\"w\",stdout); scanf(\"%d%d%d%d\",&amp;n[1],&amp;n[2],&amp;n[3],&amp;n[4]); Dfs_Pai(1); for(int i=1;i&lt;=cnt;i++) Dfs_Judge(i); for(int i=1;i&lt;=tot;i++) r[i]=i; sort(r+1,r+1+tot,cmp); printf(\"%s\",ans[r[1]]); return 0;&#125; /*2 3 5 7*/ 4.单人纸牌【题目描述】单人纸牌游戏，共 36 张牌分成 9 叠，每叠 4 张牌面向上。每次，游戏者可以从某两个不同的牌堆最顶上取出两张牌面相同的牌（如黑桃 10 和梅花 10）并且一起拿走。如果最后所有纸牌都被取走，则游戏者就赢了，否则游戏者就输了。George 很热衷于玩这个游戏，但是一旦有时有多种选择的方法，George 就不知道取哪一种好了，George 会从中随机地选择一种走，例如：顶上的 9 张牌为 KS,KH,KD,9H,8S,8D,7C,7D，6H，显然有 5 种取法： (KS,KH),(KS,KD),(KH,KD),(8S,8D),(7C,7D)，当然 George 取到每一种取法的概率都是 1/5。有一次，George 的朋友 Andrew 告诉他，这样做是很愚蠢的，不过 George 不相信，他认为如此玩最后成功的概率是非常大的。请写一个程序帮助 George 证明他的结论：计算按照他的策略，最后胜利的概率。 【输入格式】9 行每行 4 组用空格分开的字串，每个字串两个字符，分别表示牌面和花色，按照从堆底到堆顶的顺序给出。 【输出格式】一行，最后胜利的概率，精确到小数点后 6 位。 【输入样例】AS 9S 6C KS JC QH AC KH 7S QD JD KD QS TS JS 9H 6D TD AD 8S QC TH KC 8D 8C 9D TC 7C 9C 7H JH 7D8H 6S AH 6H 【输出样例】0.589314 Solution记忆化搜索轻松搞定，其实比较裸吧。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;char ch[10][5];bool f[5][5][5][5][5][5][5][5][5];double dp[5][5][5][5][5][5][5][5][5];double dfs(int c1,int c2,int c3,int c4,int c5,int c6,int c7,int c8,int c9)&#123; if(f[c1][c2][c3][c4][c5][c6][c7][c8][c9]) return dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]; f[c1][c2][c3][c4][c5][c6][c7][c8][c9]=true; int c[10]; c[1]=c1;c[2]=c2;c[3]=c3;c[4]=c4; c[5]=c5;c[6]=c6;c[7]=c7;c[8]=c8;c[9]=c9; int sum=0; for(int i=1;i&lt;=9;i++) for(int j=i+1;j&lt;=9;j++) &#123; if(ch[i][c[i]]==ch[j][c[j]]&amp;&amp;(c[i]&gt;0)&amp;&amp;(c[j]&gt;0)) &#123; sum++; c[i]--;c[j]--; dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]+=dfs(c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9]); c[i]++;c[j]++; &#125; &#125; if(sum!=0) dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]/=sum; return dp[c1][c2][c3][c4][c5][c6][c7][c8][c9];&#125;int main()&#123; freopen(\"double.in\",\"r\",stdin); freopen(\"double.out\",\"w\",stdout); for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=4;j++) &#123; char a,b; cin&gt;&gt;a&gt;&gt;b; ch[i][j]=a; &#125; f[0][0][0][0][0][0][0][0][0]=1; dp[0][0][0][0][0][0][0][0][0]=1; dp[4][4][4][4][4][4][4][4][4]=dfs(4,4,4,4,4,4,4,4,4); printf(\"%.6f\",dp[4][4][4][4][4][4][4][4][4]); return 0;&#125;/*AS 9S 6C KSJC QH AC KH7S QD JD KDQS TS JS 9H6D TD AD 8SQC TH KC 8D8C 9D TC 7C9C 7H JH 7D8H 6S AH 6H*/","categories":[],"tags":[]},{"title":"noip模拟赛2017.7.20","slug":"[noip模拟赛2017.7.20]","date":"2017-07-20T07:01:57.632Z","updated":"2017-07-20T07:01:15.227Z","comments":true,"path":"2017/07/20/[noip模拟赛2017.7.20]/","link":"","permalink":"https://dextertyw.github.io/2017/07/20/[noip模拟赛2017.7.20]/","excerpt":"题目名称 产品排序 分球 地图 数页码 提交文件 sort.* ball.* map.* count.* 输入文件 sort.in ball.in map.in count.in 输出文件 sort.out ball.out map.out count.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 32MB 题目来源 vijos vijos 模拟题 模拟题","text":"题目名称 产品排序 分球 地图 数页码 提交文件 sort.* ball.* map.* count.* 输入文件 sort.in ball.in map.in count.in 输出文件 sort.out ball.out map.out count.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 32MB 题目来源 vijos vijos 模拟题 模拟题 产品排序题目描述有一系列产品，给定每个产品的加工时间和冷却成型时间（冷却过程产品之间没有关系，是单独 冷却的）。现在你手上有两台机器可以用来加工，你需要安排产品加工的顺序以及去哪台机器加工， 使得所有产品都成型的时间最早。机器之间互不相关，可以同时进行工作，一个机器一个时刻只能加 工一个产品。 输入格式第一行一个数 n，表示产品个数，以下 n 行，每行两个数分别表示产品的加工时间 A[i]和冷却时间 B[i]。 输出格式一个数，表示所有产品成型的最早时间。 数据规模对于 20%的数据，满足 n&lt;=6;对于 100%的数据，满足 n,A[i],B[i]&lt;=200。 输入样例3 14 33 41 输出样例6 题解对于一个机器的情况，我们贪心处理，按冷却时间降序排序一定是最优的(因为冷却时间长的肯定先加工嘛)然后考虑两个机器的情况，因为所有产品都是要加工的，所以两个机器加工的总时间一定，那么我们可以动规处理，dp[i][j]表示加工前i件产品，其中第一个机器加工时长为j的时候，最少什么时候加工完成，如此说来，状态转移方程就好写了如果用第一台机器加工，那么就是 如果用第二台机器加工，那么就是 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF (1&lt;&lt;30)using namespace std;int dp[202][40400];struct node&#123; int t1,t2;&#125;a[202];bool cmp(node x,node y)&#123; return x.t2&gt;y.t2;&#125;int sum[202];int main()&#123; freopen(\"sort.in\",\"r\",stdin); freopen(\"sort.out\",\"w\",stdout); int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i].t1,&amp;a[i].t2); sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]+a[i].t1; for(int ta=0;ta&lt;=sum[i];ta++)&#123; int tb=sum[i]-ta; dp[i][ta]=INF; if(ta&gt;=a[i].t1) dp[i][ta]=min(dp[i][ta],max(ta+a[i].t2,dp[i-1][ta-a[i].t1])); if(tb&gt;=a[i].t1) dp[i][ta]=min(dp[i][ta],max(tb+a[i].t2,dp[i-1][ta])); &#125; &#125; int ans=INF; for(int ta=0;ta&lt;=sum[n];ta++) ans=min(dp[n][ta],ans); printf(\"%d\",ans);&#125; 分球题目描述有 N 个标号的球分到 M 个无差别的盒子里，每个盒子至少有一个球，问方案数。 输入格式多组数据；每部分一行两个数 N、M。 输出格式每组数据输出一行，一个数，表示方案数。 数据规模对于 20%的数据，满足 1&lt;=N，M&lt;=10;对于 100%的数据，满足 1&lt;=N，M&lt;=100，数组组数&lt;=10。 输入样例42 11 输出样例7 1 样例解释N=4,M=21,234 ；2,134；3,124；4,123；12,34；13,24；14,23 题解高精度DP，待填坑 地图题目描述给定一张地图，定义 X 表示陆地，O 表示海洋。两个格子连通，当且仅当它们共边。一个大陆定 义是一个极大的陆地连通块。极大的连通块的定义是不存在一个格子与当前连通块中的某个格子相连 但不属于当前连通块。问地图中有几个大陆。 输入格式第一行两个数 N，M，表示地图的大小，以下 N 行，每行 M 个字母。 输出格式一个数，表示大陆个数。 数据规模对于 30%的数据，满足 1&lt;=N，M&lt;=50。对于 100%的数据，满足 1&lt;=N，M&lt;=1000。 输入样例5 5XXXOOOOXOOOOOXXXOOOOXOXXX 输出样例4 题解简单的搜索12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF (1&lt;&lt;30)#define LL long longusing namespace std;bool mp[2000][2000];int m,n,ans;char s[2000];int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;void dfs(int x,int y)&#123; mp[x][y]=true; for(int i=0;i&lt;4;i++)&#123; int xx=x+dx[i],yy=y+dy[i]; if(!mp[xx][yy]) dfs(xx,yy); &#125;&#125;int main()&#123; freopen(\"map.in\",\"r\",stdin); freopen(\"map.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",s+1); for(int j=1;j&lt;=m;j++) if(s[j]=='O') mp[i][j]=true; &#125; for(int i=1;i&lt;=n;i++) mp[i][0]=mp[i][m+1]=true; for(int j=1;j&lt;=m;j++) mp[0][j]=mp[n+1][j]=true; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(!mp[i][j])&#123; dfs(i,j); ans++; &#125; printf(\"%d\",ans);&#125;/*5 5XXXOOOOXOOOOOXXXOOOOXOXXX*/ 数页码题目描述一本书的页码是从 1-n 编号的连续整数：1，2，3…，n。请你求出全部页码中所有单个数字的 和，例如第 123 页，它的和就是 1+2+3=6。 输入格式一行为 n(1&lt;=n&lt;=10^9)。 输出格式一行，代表所有单个数字的和。 输入样例3456789 输出样例96342015 题解可以考虑分位处理，先统计个位上出现的，再算十位…以此类推。但是要注意不要忘了每个位置剩下的，因为由于每个位的数字不相同，所以可能…这个只能意会吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int c[10],n;long long ans;int Get_Num(int x)&#123; int rtn=0; while(x) &#123; x/=10; rtn++; &#125; return rtn;&#125;int main()&#123; freopen(\"count.in\",\"r\",stdin); freopen(\"count.out\",\"w\",stdout); scanf(\"%d\",&amp;n); int num=Get_Num(n); int pow=1; for(int j=1;j&lt;=num;j++) &#123; pow*=10; int Pre_Number=n/pow*pow; int Bac_Number=n-Pre_Number; for(int i=1;i&lt;=9;i++) c[i]+=Pre_Number/10; int Re_Number=Bac_Number*10/pow; for(int i=1;i&lt;Re_Number;i++) c[i]+=pow/10; c[Re_Number]+=Bac_Number-Re_Number*(pow/10)+1; &#125; for(int i=1;i&lt;=9;i++) ans+=c[i]*i; printf(\"%d\\n\",ans);&#125;/*31 43 34 1*/","categories":[],"tags":[]},{"title":"manacher练习题","slug":"回文检测","date":"2017-07-19T13:39:50.356Z","updated":"2017-07-19T10:52:21.193Z","comments":true,"path":"2017/07/19/回文检测/","link":"","permalink":"https://dextertyw.github.io/2017/07/19/回文检测/","excerpt":"回文检测做这道题的目的为了联系一下Manacher，也会专门再写一篇Manacher的专题题目描述据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母’A’-‘Z’和’a’-‘z’。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。","text":"回文检测做这道题的目的为了联系一下Manacher，也会专门再写一篇Manacher的专题题目描述据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母’A’-‘Z’和’a’-‘z’。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。 输入输出格式输入格式： 输入文件不会超过20,000字符。这个文件可能一行或多行，但是每行都不超过80个字符(不包括最后的换行符)。 输出格式： 输出的第一行应该包括找到的最长的回文的长度。下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。如果有多个回文长度都等于最大值，输出最前面出现的那一个。 输入输出样例输入样例#1：\\Confucius say: Madam, I’m Adam.\\输出样例#1：\\11Madam, I’m Adam 说明题目翻译来自NOCOW。\\USACO Training Section 1.3 题解这道题可能是Manacher的模板题吧，我总觉得马拉车这个名字很蠢….以前还真的是以为和马有关系，知道真相的我….. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;char ch[30010],c[50010];int p[50010],trs[50010],ans=-1,Left,Right,cnt,cht,tmp=-1;void check(int pos)&#123; if(p[pos]&gt;tmp) &#123; tmp=p[pos]; ans=p[pos]-1; Left=pos-p[pos]+1,Right=pos+p[pos]-1; if(c[Left]=='#')Left++,Right--; &#125;&#125;void Manacher()&#123; int MaxRight=0,pos=0; for(int i=1;i&lt;=cnt;i++)&#123; int j=2*pos-i; if(i&lt;MaxRight)&#123; p[i]=min(MaxRight-i+1,p[j]); check(i); &#125; else&#123; int ll=i,rr=i; while(ll-1&gt;=0&amp;&amp;rr+1&lt;=cnt+1) &#123; if(c[ll]==c[rr])&#123; ll--;rr++;p[i]++; &#125; else break; &#125; check(i); pos=i,MaxRight=p[i]+pos-1; &#125; &#125;&#125;int main()&#123;#ifdef YSW freopen(\"in.txt\",\"r\",stdin);#endif char cc; c[cnt]='$';c[++cnt]='#'; while((cc=getchar())!=EOF) &#123; ch[++cht]=cc; if(ch[cht]&gt;='a'&amp;&amp;ch[cht]&lt;='z') c[++cnt]=ch[cht],trs[cnt]=cht,c[++cnt]='#';; if(ch[cht]&gt;='A'&amp;&amp;ch[cht]&lt;='Z') c[++cnt]=ch[cht]-'A'+'a',trs[cnt]=cht,c[++cnt]='#'; &#125; Manacher(); int l=trs[Left],r=trs[Right]; printf(\"%d\\n\",ans); for(int i=l;i&lt;=r;i++) printf(\"%c\",ch[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"noip模拟赛2017.7.11","slug":"[noip模拟赛2017.7.11]","date":"2017-07-19T13:39:45.993Z","updated":"2017-07-19T11:33:10.672Z","comments":true,"path":"2017/07/19/[noip模拟赛2017.7.11]/","link":"","permalink":"https://dextertyw.github.io/2017/07/19/[noip模拟赛2017.7.11]/","excerpt":"模拟试题(三)【试题概览】 题目名称 中位数 敲砖块 单词 邮递员送信 提交文件 median.* brike.* words.* post.* 输入文件 median.in brike.in words.in post.in 输出文件 median.out brike.out words.out post.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB","text":"模拟试题(三)【试题概览】 题目名称 中位数 敲砖块 单词 邮递员送信 提交文件 median.* brike.* words.* post.* 输入文件 median.in brike.in words.in post.in 输出文件 median.out brike.out words.out post.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB 中位数【题目描述】有一个长度为 N 的数列{A1,A2,…,AN}，这 N 个数字恰好是 1..N 的一个排列。你需要统计有多少个 子序列{Ai,Ai+1,…,Aj}满足：i&lt;=j 且 j-i+1 为奇数，序列的中位数为 B。例如{5,1,3}的中位数为 3。 【输入格式】第一行包含两个正整数 N 和 B。第二行包含 N 个整数，第 i 个整数为 Ai. 【输出格式】仅包含一个整数，为满足条件的子序列的个数。 【数据规模】对于 30%的数据，满足 N&lt;=100;对于 60%的数据，满足 N&lt;=1000;对于 100%的数据，满足 N&lt;=100000,1&lt;=B&lt;=N。 【输入样例】7 4 5 7 2 4 3 1 6 【输出样例】4 题解第一题想了一个比n^2小那么一点的方法，奈何忘记判断边界，直接gg（md还有20分）。8020.！&amp;￥#！正解直接用d[i]前缀和的形式统计i位置及以前比B大的数和比它小的数个数之差，然后如果在B位置后面存在一个位置j使d[j]==d[i],则说明在i~j这段区间中比B大的数与比B小的数相等，和一个合法区间。然后如何O(n)判断？就是桶排序的类似思想，打标记。1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,b,a[100010],gre[100010],les[100010],num[100010],flag[200010];int trs(int x)&#123;return x+100010;&#125;int main()&#123; freopen(&quot;median.in&quot;,&quot;r&quot;,stdin); freopen(&quot;median.out&quot;,&quot;w&quot;,stdout); int pos,ans=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;b); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; gre[i]=gre[i-1],les[i]=les[i-1]; if(a[i]&gt;b)gre[i]++; if(a[i]&lt;b)les[i]++; if(a[i]==b)pos=i; num[i]=gre[i]-les[i]; &#125; for(int i=0;i&lt;=pos;i++)flag[trs(num[i])]++; for(int i=pos;i&lt;=n;i++)ans+=flag[trs(num[i])]; cout&lt;&lt;ans; return 0;&#125;/*7 47 2 4 3 6 5 1*/ 敲砖块【题目描述】在一个凹槽中放置了 N 层砖块，最上面的一层有 N 块砖，从上到下每层依次减少一块砖。每块砖 都有一个分值，敲掉这块砖就能得到相应的分值，如图所示14 15 4 3 2333 33 76 22 13 1222 2331如果你想敲掉第 i 层的第 j 块砖的话，若 i=1，你可以直接敲掉它；若 i&gt;1，则你必须先敲掉第 i-1 层的第 j 和第 j+1 块砖。你现在可以敲掉最多 M 块砖，求得分最多能有多少。 【输入格式】第一行有两个正整数 N 和 M；接下来的 N 行，描述这 N 层砖块上的分值 A[i,j]，满足 0&lt;=A[i,j]&lt;=100。 【输出格式】仅一行，包含一个整数，为最大的得分。 【数据规模】对于 20%的数据，满足 1&lt;=N&lt;=10,1&lt;=M&lt;=30;对于 100%的数据，满足 1&lt;=N&lt;=50,1&lt;=M&lt;=500。 【输入样例】4 5 2 2 3 4 8 2 7 2 3 49 【输出样例】19 题解（xjb算法）幸亏今天的第二题苟住了，dp直接AC，但我想说一下cxy想的记忆化搜索（1.因为dp真的很烦，公式推错直接gg.2.记忆化搜索还比较好想）。我们每次只处理一列中的选择方案，假设敲i及其以上（其实i以上是必然会被敲）由于敲砖方式的限制，下一列的搜索是存在限制的，必须敲掉i-1块及以上，当然也可以敲下面的。既然这个清楚了就比较好完成代码了。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define N 51using namespace std;int n,m,flag[N][N][(N*(N+1)/2)],dp[N][N][(N*(N+1)/2)],mp[N][N],sum[N][N];int dfs(int lie,int p,int lft)&#123; int rtn=sum[lie][p]; if(flag[lie][p][lft])return dp[lie][p][lft]; flag[lie][p][lft]=1; if(2*lft&lt;(p*(p+1)))return dp[lie][p][lft]=-1; if(lft&lt;0)return dp[lie][p][lft]=-1; if(lie&gt;n)return dp[lie][p][lft]=0; if(lft==0)return dp[lie][p][lft]=0; for(int i=p;i&lt;=n-lie+1;i++) &#123; int now=sum[lie][i]; int k=dfs(lie+1,max(i-1,0),lft-i); if(k==-1)break; rtn=max(now+k,rtn); &#125; return dp[lie][p][lft]=rtn; &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n-i+1;j++) scanf(&quot;%d&quot;,&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) sum[i][j]=sum[i][j-1]+mp[j][i]; printf(&quot;%d&quot;,dfs(1,0,m)); return 0;&#125; 单词【题目描述】有 N 个单词和字符串 T，按字典顺序输出以字符串 T 为前缀的所有单词。 【输入格式】第一行包含一个正整数 N；接下来 N 行，每行一个单词，长度不超过 50；最后一行包含字符串 T。 【输出格式】按字典顺序升序输出答案。 【数据规模】对于 60%的数据，满足 1&lt;=N&lt;=1000;对于 100%的数据，满足 1&lt;=N&lt;=10000 且所有字符均为小写字母。 【输入样例】6 na no ki ki ka ku k 【输出样例】ka ki ki ku 题解 很烦，string果然还是不能被接受。不过今天通过这道题也学到了，如果我们不便对于一个二维数组进行排序，我们可以间接通过对其下标的排序来完成。不过这道题的小技巧在于我们可以把要匹配的前缀也加入排列，然后再加入一个前缀后+’z’+1的一个串来保证会被派到最后一个，通过一开始的下标记录，我们可以完成对排序后的数组经行O(n)查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,cnt,l[10010],bh[10010];char ch[10010][100]; bool cmp(int x,int y)&#123; int len=min(l[x],l[y]); for(int i=0;i&lt;=len-1;i++) &#123; if(ch[x][i]==ch[y][i])continue; return ch[x][i]&lt;ch[y][i]; &#125; return l[x]&lt;l[y];&#125;int main()&#123; freopen(&quot;words.in&quot;,&quot;r&quot;,stdin); freopen(&quot;words.out&quot;,&quot;w&quot;,stdout); int pos; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,ch[i]),l[i]=strlen(ch[i]),bh[i]=i; scanf(&quot;%s&quot;,ch[0]); l[0]=strlen(ch[0]),bh[0]=0; for(int i=0;i&lt;l[0];i++) ch[n+1][i]=ch[0][i]; ch[n+1][l[0]]=&apos;z&apos;+1,l[n+1]=l[0]+1,bh[n+1]=n+1; stable_sort(bh,bh+2+n,cmp); for(int i=0;i&lt;=n+1;i++)if(bh[i]==0)&#123;pos=i;break;&#125; for(int i=pos+1;i;i++)&#123; if(bh[i]==n+1)break; else printf(&quot;%s\\n&quot;,ch[bh[i]]); &#125; return 0;&#125;/*6nanokikikakuk*/ 邮递员送信【题目描述】有一个邮递员要送东西，邮局在结点 1。他总共要送 N-1 样东西，其目的地分别是 2-N。由于这个 城市的交通比较繁忙，因此所有的道路都是单行的，共有 M 条道路，通过每条道路需要一定的时间。 这个邮递员每次只能带一样东西。求送完这 N-1 样东西并且最终回到邮局最少需要多少时间。 【输入格式】第一行包含一个正整数 N 和 M；接下来有 M 行，每行三个正整数 U、V、W，表示该条道路为从 U 到 V 的，且通过这条道路需要 W 的时间。满足 1&lt;=U,V&lt;=N,1&lt;=W&lt;=100000，输入保证任意两点都能互相到达。 【输出格式】包含一个整数，为最少需要的时间 【数据规模】30%的数据，1&lt;=N&lt;=200;100%的数据，1&lt;=N&lt;=1000，1&lt;=M&lt;=10000. 【输入样例】注意：如果有这样的情况：（1109） （1102） （1101）以最小的 w=1 进行存储 5 10 2 3 5 1 5 5 3 5 6 1 2 8 1 3 8 5 3 4 4 1 8 4 5 3 3 5 6 5 4 2 【输出样例】83 题解题目真的很有病，明明说了边数不超过10000，结果来个80000的数据，也是没谁了。由于题目中的边是单向边，所以建个反向边跑一跑就完事了，代码写的丑是真的，后来改题的时候弄了半天，傻X出题人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long longusing namespace std;int n,m,cnt,p[1010],edge[1010][1010],vis[1010];LL dis[1010];struct node&#123; int a,b,w,nt;&#125;e[10010],t[10010];void add1(int x,int y,int w)&#123; cnt++; e[cnt].a=x,e[cnt].b=y,e[cnt].w=w; e[cnt].nt=p[x],p[x]=cnt;&#125;void add2(int x,int y,int w)&#123; cnt++; t[cnt].a=x,t[cnt].b=y,t[cnt].w=w; t[cnt].nt=p[x],p[x]=cnt;&#125;queue&lt;int&gt;q1,q2;void spfa1()&#123; for(int i=1;i&lt;=n;i++)dis[i]=1e15;dis[1]=0; q1.push(1);vis[1]=1; while(!q1.empty())&#123; int k=q1.front();q1.pop();vis[k]=0; for(int i=p[k];i;i=e[i].nt)&#123; int kk=e[i].b; if(dis[kk]&gt;dis[k]+e[i].w)&#123; dis[kk]=dis[k]+e[i].w; if(!vis[kk])&#123; vis[kk]=1; q1.push(kk); &#125; &#125; &#125; &#125;&#125;void spfa2()&#123; for(int i=1;i&lt;=n;i++)dis[i]=1e15;dis[1]=0; q2.push(1);vis[1]=1; while(!q2.empty())&#123; int k=q2.front();q2.pop();vis[k]=0; for(int i=p[k];i;i=t[i].nt)&#123; int kk=t[i].b; if(dis[kk]&gt;dis[k]+t[i].w)&#123; dis[kk]=dis[k]+t[i].w; if(!vis[kk])&#123; vis[kk]=1; q2.push(kk); &#125; &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;post.in&quot;,&quot;r&quot;,stdin); freopen(&quot;post.out&quot;,&quot;w&quot;,stdout); LL ans=0; memset(edge,63,sizeof(edge)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); edge[x][y]=min(edge[x][y],z); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(edge[i][j]&lt;=100000&amp;&amp;i!=j) add1(i,j,edge[i][j]); spfa1(); for(int i=2;i&lt;=n;i++) ans+=dis[i]; memset(p,0,sizeof(p)),cnt=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(edge[i][j]&lt;=100000&amp;&amp;i!=j) add2(j,i,edge[i][j]); spfa2(); for(int i=2;i&lt;=n;i++) ans+=dis[i]; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;/*5 102 3 51 5 53 5 61 2 81 3 85 3 44 1 84 5 33 5 6 5 4 2*/*/","categories":[],"tags":[]}]}