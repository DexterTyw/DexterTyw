{"meta":{"title":"Dexter","subtitle":"For Our Future","description":"The Revival","author":"by Dexter Yue","url":"https://dextertyw.github.io"},"pages":[{"title":"About","date":"2017-07-26T08:38:04.000Z","updated":"2017-09-29T15:09:18.372Z","comments":true,"path":"about/index.html","permalink":"https://dextertyw.github.io/about/index.html","excerpt":"","text":"关于博主：基本1.一名学OI的菜鸟，由于不想学综合，在竞赛班苟着… 2.没有什么比较高远的目标，还是继续苟着 3.然后最重要的，不是二次元QAQ，Orz 4.处于幼年时期，如果有大佬不幸路过，别d.Orz 5.I love “Tell Your Wonders” 日常1.被同组的**阳各种花式吊打，心服口服 2.求同组的**阳带躺，QAQ 3.有时候会打打dota2，也是应同学之邀QAQ 4.coc（垃圾7本） 关于喜欢的人和事1.不谈明星也是有的，谈了明星也是唯一的 2.心里的期限还是很长，觉得应该要继续等 3.喜欢的事就是和喜欢的人在一起就可以 4.上面的我觉得其实还ok，23333333 一切都是为了将来，加油！There for You"},{"title":"Links","date":"2017-07-26T07:35:00.745Z","updated":"2017-07-26T07:35:00.745Z","comments":true,"path":"link/index.html","permalink":"https://dextertyw.github.io/link/index.html","excerpt":"","text":"AnoxiacxyxljHeret1chamsterwk"}],"posts":[{"title":"模拟退火 Simolate Anneal","slug":"Simolate Anneal","date":"2017-08-25T00:46:40.997Z","updated":"2017-08-25T00:51:38.362Z","comments":true,"path":"2017/08/25/Simolate Anneal/","link":"","permalink":"https://dextertyw.github.io/2017/08/25/Simolate Anneal/","excerpt":"Descriptiongty又虐了一场比赛，被虐的蒟蒻们决定吊打gty。gty见大势不好机智的分出了n个分身，但还是被人多势众的蒟蒻抓住了。蒟蒻们将n个gty吊在n根绳子上，每根绳子穿过天台的一个洞。这n根绳子有一个公共的绳结x。吊好gty后蒟蒻们发现由于每个gty重力不同，绳结x在移动。蒟蒻wangxz脑洞大开的决定计算出x最后停留处的坐标，由于他太弱了决定向你求助。不计摩擦，不计能量损失，由于gty足够矮所以不会掉到地上。","text":"Descriptiongty又虐了一场比赛，被虐的蒟蒻们决定吊打gty。gty见大势不好机智的分出了n个分身，但还是被人多势众的蒟蒻抓住了。蒟蒻们将n个gty吊在n根绳子上，每根绳子穿过天台的一个洞。这n根绳子有一个公共的绳结x。吊好gty后蒟蒻们发现由于每个gty重力不同，绳结x在移动。蒟蒻wangxz脑洞大开的决定计算出x最后停留处的坐标，由于他太弱了决定向你求助。不计摩擦，不计能量损失，由于gty足够矮所以不会掉到地上。 Input输入第一行为一个正整数n(1&lt;=n&lt;=10000)，表示gty的数目。接下来n行,每行三个整数xi，yi，wi，表示第i个gty的横坐标，纵坐标和重力。对于20%的数据，gty排列成一条直线。对于50%的数据，1&lt;=n&lt;=1000。对于100%的数据，1&lt;=n&lt;=10000,-100000&lt;=xi,yi&lt;=100000 Output输出1行两个浮点数（保留到小数点后3位），表示最终x的横、纵坐标。 Sample Input3 0 0 1 0 2 1 1 1 1 Sample Output0.577 1.000 HINTNothing left Solution第一次接触模拟退火，还是好好的理一理，其实学长说我们学早了，不过我和**阳都觉得这个蛮有意思的，就试试看QAQ。 首先退火这个名次来源于物理,我们回顾一下历史：美国物理学家 N.Metropolis 和同仁在1953年发表研究复杂系统、计算其中能量分布的文章，他们使用蒙特卡罗模拟法计算多分子系统中分子的能量分布。这相当于是本文所探讨之问题的开始，事实上，模拟退火中常常被提到的一个名词就是Metropolis准则，后面我们还会介绍。 美国IBM公司物理学家 S.Kirkpatrick、C. D. Gelatt 和 M. P. Vecchi 于1983年在《Science》上发表了一篇颇具影响力的文章：《以模拟退火法进行最优化（Optimization by Simulated Annealing）》。他们借用了Metropolis等人的方法探讨一种旋转玻璃态系统（spin glass system）时，发觉其物理系统的能量和一些组合最优（combinatorial optimization）问题（著名的旅行推销员问题TSP即是一个代表例子）的成本函数相当类似：寻求最低成本即似寻求最低能量。由此，他们发展出以 Metropolis 方法为本的一套算法，并用其来解决组合问题等的寻求最优解。 几乎同时，欧洲物理学家 V.Carny 也发表了几乎相同的成果，但两者是各自独立发现的；只是Carny“运气不佳”，当时没什么人注意到他的大作；或许可以说，《Science》杂志行销全球，“曝光度”很高，素负盛名，而Carny却在另外一本发行量很小的专门学术期刊《J.Opt.Theory Appl.》发表其成果因而并未引起应有的关注。 Kirkpatrick等人受到Metropolis等人用蒙特卡罗模拟的启发而发明了“模拟退火”这个名词，因为它和物体退火过程相类似。寻找问题的最优解（最值）即类似寻找系统的最低能量。因此系统降温时，能量也逐渐下降，而同样意义地，问题的解也“下降”到最值。 关于什么是退火…其实在热力学上，退火现象是指物体逐渐降温的物理现象，温度越低，自然物体的能量越低，那么分子的运动也相对要稳定，形象的理解为物体分子的运动范围就很小了 而这个性质体现在代码编程中就是搜索的范围是有时间的推移逐渐缩小的。 爬山与模拟退火的区别…爬山算法基于一种简单的贪心，枚举可行点后，选取一个最优的状态作为当前的解，然后再去搜索其他的解。 很显然，爬山算法只能求的局部最优解，当然如果你的初始状态选得合理，也是可以搜出答案的。 而模拟退火的优越之处，在于他会根据一定的概率来选择当且这个看似不可能成为最优解的答案，这个概率的公式待会再说。如果我们接受了一个“错误答案”，我们就有跳出这个局部的可能，才能搜到正确答案。 如上图中的b点右边的峰值。 一个公式（准则）这个我就解释不了了，记下来就行了。 根据Metropolis准则，粒子在温度T时趋于平衡的概率为exp(-ΔE/(kT))，其中E为温度T时的内能，ΔE为其改变数,k为Boltzmann常数。Metropolis准则常表示为 Metropolis准则表明，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：P(dE) = exp( dE/(kT) )。其中k是一个常数，exp表示自然指数，且dE&lt;0。所以P和T正相关。这条公式就表示：温度越高，出现一次能量差为dE的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于dE总是小于0（因为退火的过程是温度逐渐下降的过程），因此dE/kT &lt; 0 ，所以P(dE)的函数取值范围是(0,1) 。随着温度T的降低，P(dE)会逐渐降低。 然后我们就可以在(0,1)之间rand一个数，然后如果p(dE)&gt;rand，依旧更新答案，否则舍弃。 SA的实质其实我们可以从公式或者是待会的代码中发现，模拟退火实际上是把我们需要的目标函数f(x),转化成一个虚拟物体的内能E(x)。经行模拟。 温度是一个很抽象但是和重要的控制参数，它不仅控制着搜索次数，更重要的是它控制着搜索的范围。 神犇的解释：由初始解 i 和控制参数初值 t 开始，对当前解重复“产生新解→计算目标函数差→接受或丢弃”的迭代，并逐步衰减 t 值，算法终止时的当前解即为所得近似最优解，这是基于蒙特卡罗迭代求解法的一种启发式随机搜索过程。退火过程由冷却进度表(Cooling Schedule)控制，包括控制参数的初值 t 及其衰减因子Δt 、每个 t 值时的迭代次数L和停止条件S。 两句话的总结对于一个优于当前解的答案，我们必然接受，对于一个不优于当前解的答案，我们以一定概率接受。 所以我们可以看到Simolate Anneal是有可能做不出正解的，所以通常我们会外层循环多次，逼迫其找到最优解。 言归正传传送门の大概就是广义上的费马点，我们可以在初始状态选一个点，然后由它开始搜索。具体的初始温度，和每次温度下降的常数delta，可以根据题目本身和做题经验结合考虑，delta越趋近1，答案往往更精确，但是也付出了时间复杂度的代价。 再一个可能不是太好调试吧23333QAQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;struct Point&#123; double x,y; Point(double a=0,double b=0):x(a),y(b) &#123;&#125;&#125;;const int maxn=10005;const double INF=1e18;Point p[maxn];double w[maxn];Point tar;double mi=INF;int n; double dist(Point a,Point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;double randx()&#123; return 1.0*rand()/RAND_MAX;&#125;double solve(Point a)&#123; double res=0; for(int i=1;i&lt;=n;i++)res+=w[i]*dist(a,p[i]); if(res&lt;mi)mi=res,tar=a; return res;&#125;void sa()&#123; double dE,T=1e5; Point a=tar,now; while(T&gt;0.001)&#123; now.x=a.x+T*(randx()*2-1); now.y=a.y+T*(randx()*2-1); dE=solve(a)-solve(now); if(dE&gt;0||exp(dE/T)&gt;randx()) a=now; T*=0.97; &#125; for(int i=1;i&lt;=1000;i++)&#123; now.x=tar.x+T*(randx()*2-1); now.y=tar.y+T*(randx()*2-1); solve(now); &#125;&#125;int main()&#123; srand(20000512); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lf%lf%lf\",&amp;p[i].x,&amp;p[i].y,&amp;w[i]); tar.x+=p[i].x,tar.y+=p[i].y; &#125; tar.x/=n,tar.y/=n; solve(tar);sa(); printf(\"%.3f %.3f\\n\",tar.x,tar.y); return 0;&#125;","categories":[],"tags":[{"name":"启发式搜索","slug":"启发式搜索","permalink":"https://dextertyw.github.io/tags/启发式搜索/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://dextertyw.github.io/tags/模拟退火/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://dextertyw.github.io/tags/学习笔记/"}]},{"title":"bzoj2118-墨墨的等式","slug":"[bzoj2118]墨墨的等式","date":"2017-08-24T11:33:43.349Z","updated":"2017-08-24T11:33:17.855Z","comments":true,"path":"2017/08/24/[bzoj2118]墨墨的等式/","link":"","permalink":"https://dextertyw.github.io/2017/08/24/[bzoj2118]墨墨的等式/","excerpt":"Description墨墨突然对等式很感兴趣，他正在研究a1x1+a2y2+…+anxn=B存在非负整数解的条件，他要求你编写一个程序，给定N、{an}、以及B的取值范围，求出有多少B可以使等式存在非负整数解。","text":"Description墨墨突然对等式很感兴趣，他正在研究a1x1+a2y2+…+anxn=B存在非负整数解的条件，他要求你编写一个程序，给定N、{an}、以及B的取值范围，求出有多少B可以使等式存在非负整数解。 Input输入的第一行包含3个正整数，分别表示N、BMin、BMax分别表示数列的长度、B的下界、B的上界。输入的第二行包含N个整数，即数列{an}的值。 Output输出一个整数，表示有多少b可以使等式存在非负整数解。 Sample Input2 5 103 5 Sample Output5 HINT对于100%的数据，N≤12，0≤ai≤5*10^5，1≤BMin≤BMax≤10^12。 Solution本来是想练练dijkstra，然后翻到了这个神题，太神了~首先第一反应 应该是背包dp，但是数据范围就无语了。。。 也没有什么好引入的把，，，就是一个思维题。。。 记 假设 p 是符合条件的B值，那么显然 p+mn 也是符合条件的而任意一个p 都可以被表示成：其中而每个 p 和一个 r 唯一对应，所以我们只需要知道那些p值是可以用ai表示出来的就好，而我们只需要求那个最小的。如果记 ans[m]为[1,m]内的答案，那么显然这满足前缀和的性质。 若 且 Vx 是其对应的一个有效最小值，那么其对答案的贡献就是 然后求和就可以了2333333然后至于为什么dijktra可以判断出一个有效值，先说一下连边方式：按照这样子连边是不会连出不合法的解，因为权值都是ai。最短路是保证了解最小的性质。 以上.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define pa pair&lt;int,int&gt;#define LL long longusing namespace std;const int INF=2147483647;int n,mn=INF,p[5000010],cnt;LL L,R,ans=0,dis[5000010];int a[20];bool vis[5000010];struct node&#123; int a,b,nt,w;&#125;e[6000010];void add(int x,int y,int z)&#123; e[++cnt].a=x,e[cnt].b=y,e[cnt].w=z; e[cnt].nt=p[x],p[x]=cnt;&#125;priority_queue&lt;pa,vector&lt;pa&gt;,greater&lt;pa&gt; &gt;q; void dijkstra()&#123; memset(dis,127,sizeof(dis)); q.push(make_pair(0,0)); dis[0]=0; while(!q.empty())&#123; int now=q.top().second;q.pop(); if(vis[now])continue;vis[now]=true; for(int i=p[now];i;i=e[i].nt)&#123; int to=e[i].b; if(dis[to]&gt;dis[now]+e[i].w)&#123; dis[to]=dis[now]+e[i].w; q.push(make_pair(dis[to],to)); &#125; &#125; &#125;&#125;int main()&#123;#ifdef YSW freopen(\"in.txt\",\"r\",stdin);#endif scanf(\"%d%lld%lld\",&amp;n,&amp;L,&amp;R); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]),mn=min(mn,a[i]); for(int i=0;i&lt;mn;i++) for(int j=1;j&lt;=n;j++)&#123; add(i,(i+a[j])%mn,a[j]); &#125; dijkstra(); for(int i=0;i&lt;mn;i++)&#123; if(R&gt;=dis[i])ans+=(R-dis[i])/mn+1; if(L-1&gt;=dis[i])ans-=(L-1-dis[i])/mn+1; &#125; printf(\"%lld\",ans); return 0; &#125;","categories":[],"tags":[{"name":"dijkstra","slug":"dijkstra","permalink":"https://dextertyw.github.io/tags/dijkstra/"},{"name":"数学之美","slug":"数学之美","permalink":"https://dextertyw.github.io/tags/数学之美/"},{"name":"好题","slug":"好题","permalink":"https://dextertyw.github.io/tags/好题/"}]},{"title":"Sdoi2010大陆争霸","slug":"[bzoj1922][Sdoi2010]大陆争霸","date":"2017-08-24T01:17:22.817Z","updated":"2017-08-24T01:24:00.170Z","comments":true,"path":"2017/08/24/[bzoj1922][Sdoi2010]大陆争霸/","link":"","permalink":"https://dextertyw.github.io/2017/08/24/[bzoj1922][Sdoi2010]大陆争霸/","excerpt":"Description在一个遥远的世界里有两个国家：位于大陆西端的杰森国和位于大陆东端的 克里斯国。两个国家的人民分别信仰两个对立的神：杰森国信仰象征黑暗和毁灭 的神曾·布拉泽，而克里斯国信仰象征光明和永恒的神斯普林·布拉泽。 幻想历 8012年 1月，杰森国正式宣布曾·布拉泽是他们唯一信仰的神，同 时开始迫害在杰森国的信仰斯普林·布拉泽的克里斯国教徒。 幻想历 8012年 3月2日，位于杰森国东部小镇神谕镇的克里斯国教徒发动 起义。 幻想历 8012年 3月7日，神谕镇的起义被杰森国大军以残酷手段镇压。 幻想历 8012年 3月8日，克里斯国对杰森国宣战。由数十万大军组成的克 里斯军团开至两国边境，与杰森军团对峙。 幻想历 8012年 4月，克里斯军团攻破杰森军团防线进入神谕镇，该镇幸存 的克里斯国教徒得到解放。","text":"Description在一个遥远的世界里有两个国家：位于大陆西端的杰森国和位于大陆东端的 克里斯国。两个国家的人民分别信仰两个对立的神：杰森国信仰象征黑暗和毁灭 的神曾·布拉泽，而克里斯国信仰象征光明和永恒的神斯普林·布拉泽。 幻想历 8012年 1月，杰森国正式宣布曾·布拉泽是他们唯一信仰的神，同 时开始迫害在杰森国的信仰斯普林·布拉泽的克里斯国教徒。 幻想历 8012年 3月2日，位于杰森国东部小镇神谕镇的克里斯国教徒发动 起义。 幻想历 8012年 3月7日，神谕镇的起义被杰森国大军以残酷手段镇压。 幻想历 8012年 3月8日，克里斯国对杰森国宣战。由数十万大军组成的克 里斯军团开至两国边境，与杰森军团对峙。 幻想历 8012年 4月，克里斯军团攻破杰森军团防线进入神谕镇，该镇幸存 的克里斯国教徒得到解放。战争随后进入胶着状态，旷日持久。战况惨烈，一时间枪林弹雨，硝烟弥漫， 民不聊生。 幻想历 8012年 5月12日深夜，斯普林·布拉泽降下神谕：“Trust me, earn eternal life.”克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机 会发动奇袭，一举击败杰森国。具体地说，杰森国有 N 个城市，由 M条单向道 路连接。神谕镇是城市 1而杰森国的首都是城市 N。你只需摧毁位于杰森国首都 的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。 为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困 难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个 城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个 城市，你就必须破坏掉维持这个城市结界的所有结界发生器。 现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间 引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会 一起被破坏。你需要知道：摧毁杰森国所需的最短时间。 Input第一行两个正整数 N, M。 接下来 M行，每行三个正整数 ui, vi, wi，表示有一条从城市ui到城市 vi的单 向道路，自爆机器人通过这条道路需要 wi的时间。 之后 N 行，每行描述一个城市。首先是一个正整数 li，维持这个城市结界所 使用的结界发生器数目。之后li个1~N 之间的城市编号，表示每个结界发生器的 位置。如果 Li = 0，则说明该城市没有结界保护，保证L1 = 0 。 Output仅包含一个正整数 ，击败杰森国所需的最短时间。Sample Input 6 61 2 11 4 32 3 12 5 24 6 25 3 20001 302 3 5 Sample Output5 HINT对于 20%的数据，满足 N≤15，M≤50；对于 50%的数据，满足 N≤500，M≤6,000；对于 100%的数据，满足 N≤3,000，M≤70,000，1≤wi≤108。输入数据保证一定有解，且不会存在维持某个城市结界的结界发生器在这个城市内部。连接两个城市的道路可能不止一条， 也可能存在一个城市自己到自己的道路。 Solution以前都没有怎么用dijkstra，现在发现还是很有用的， 实在是太菜了这个应该是有限制的dijkstra，由于我们可以有无限个爆炸机器人，所以我们可以先做一遍最短路把 所有机器人安排在每个城市，然后再根据结界的限制，我们可以在独立处理出每个城市最早没有结界的时间。然后这些体现在代码里面就是不断的取max……QAQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define pa pair&lt;int,int&gt;using namespace std;int n,m,cnt,d1[3010],d2[3010],d[3010],p[3010],Link[3010][3010],num[3010];bool vis[3010];struct node&#123; int a,b,nt,w;&#125;e[70010];void add(int x,int y,int z)&#123; e[++cnt].a=x,e[cnt].b=y,e[cnt].w=z; e[cnt].nt=p[x],p[x]=cnt;&#125;priority_queue&lt;pa,vector&lt;pa&gt;,greater&lt;pa&gt; &gt;q;void dijkstra()&#123; memset(d1,127/3,sizeof(d1)); q.push(make_pair(0,1)); d1[1]=0; while(!q.empty())&#123; int now=q.top().second;q.pop(); if(vis[now])continue;vis[now]=true; int mx=max(d1[now],d2[now]); for(int i=p[now];i;i=e[i].nt)&#123; int to=e[i].b; if(d1[to]&gt;mx+e[i].w)&#123; d1[to]=mx+e[i].w; int tmp=max(d1[to],d2[to]); if(!d[to])q.push(make_pair(tmp,to)); &#125; &#125; for(int i=1;i&lt;=num[now];i++)&#123; int to=Link[now][i]; d[to]--; d2[to]=max(mx,d2[to]); int tmp=max(d2[to],d1[to]); if(!d[to])q.push(make_pair(tmp,to)); &#125; &#125; printf(\"%d\\n\",max(d1[n],d2[n]));&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int from,to,w; scanf(\"%d%d%d\",&amp;from,&amp;to,&amp;w); add(from,to,w); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;d[i]); for(int j=1;j&lt;=d[i];j++)&#123; int u; scanf(\"%d\",&amp;u); Link[u][++num[u]]=i; &#125; &#125; dijkstra(); return 0;&#125;","categories":[],"tags":[{"name":"dijkstra","slug":"dijkstra","permalink":"https://dextertyw.github.io/tags/dijkstra/"}]},{"title":"洛谷 P1174 打砖块","slug":"洛谷 P1174 打砖块","date":"2017-08-22T01:16:29.440Z","updated":"2017-08-22T01:16:12.531Z","comments":true,"path":"2017/08/22/洛谷 P1174 打砖块/","link":"","permalink":"https://dextertyw.github.io/2017/08/22/洛谷 P1174 打砖块/","excerpt":"题目描述小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下： 在刚开始的时候，有n行*m列的砖块，小红有k发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。(如图所示) 某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。 小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？","text":"题目描述小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下： 在刚开始的时候，有n行*m列的砖块，小红有k发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。(如图所示) 某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。 小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？ 输入输出格式输入格式：第一行有3个正整数，n，m，k。表示开始的时候，有n行*m列的砖块，小红有k发子弹。 接下来有n行，每行的格式如下： f1 c1 f2 c2 f3 c3 …… fm cm 其中fi为正整数，表示这一行的第i列的砖，在打碎以后的得分。ci为一个字符，只有两种可能，Y或者N。Y表示有一发奖励的子弹，N表示没有。 所有的数与字符之间用一个空格隔开，行末没有多余的空格。 输出格式：仅一个正整数，表示最大的得分。 输入输出样例 输入样例#1：3 4 29 N 5 N 1 N 8 N5 N 5 Y 5 N 5 N6 N 2 N 4 N 3 N 输出样例#1：13 说明对于20%的数据，满足1&lt;=n,m&lt;=5，1&lt;=k&lt;=10，所有的字符c都为N 对于50%的数据，满足1&lt;=n,m&lt;=200，1&lt;=k&lt;=200，所有的字符c都为N 对于100%的数据，满足1&lt;=n,m&lt;=200，1&lt;=k&lt;=200，字符c可能为Y 对于100%的数据，所有的f值满足1&lt;=f&lt;=10000 题解感觉自己好菜，只会写没有奖励的50分，如果没有奖励这个题就是一个分组dp。由于打每一列的砖块，对其列是没有影响的，故没有后效性，所以我们可以直接对列进行枚举。下面我们看看此题的正解，可以看到如果存在一个有奖励的砖块，你是首先要花费一颗子弹打，才能得到一颗子弹的奖励，故我们可以分两种情况讨论： 1.s1[i][j] 表示打第i行用了j颗子弹，且最后一颗子弹不打(留着给下一列进行开始)。2.s2[i][j] 表示打第i行用了j颗子弹，且最后一颗子弹打掉。 第一个事情就是这两个数组明显可以预处理。第二个事情就是我们如何将它们运用到dp中，对应的我们给出dp数组的定义： 1.dp1[i][j] 表示打到第i行用了j颗子弹，且最后一颗子弹不打的最高得分。2.dp2[i][j] 表示打到第i行用了j颗子弹，且最后一颗子弹打掉的最高得分。 最后一个问题就是方程的转移： 1.dp1[i][j]=max(dp1[i][j],dp1[i-1][j-g])用g颗子弹打，由于上一列最后一个本身没有打和这一行的相对应，所以使用子弹数量不变，直接转移。 2.dp2[i][j]=max(dp2[i][j],dp1[i-1][j-g]+s2[i][g])用g颗子弹打，由于上一列最后一个本身没有打，而这一列的最后一个需要打掉，相当于先最后打掉了第g个砖块。 2.dp2[i][j]=max(dp2[i][j],dp2[i-1][j-g]+s1[i][g])用g颗子弹打，由于上一列最后一个本身打掉了，而你现在用j颗子弹只能打到第g-1个砖块。 可以看到，每次我们进行了对第i列所用子弹进行了枚举，那么如果上一行的最后一颗子弹打了，就要用”额外”的一颗子弹开始打，这个可以想一下。对应上上面的三种情况。 以上。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int a[210][210],s1[210][210],s2[210][210],dp1[210][210],dp2[210][210],n,m,k;bool ward[210][210];int main()&#123;#ifdef YSW freopen(\"in.txt\",\"r\",stdin);#endif scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)&#123; char ch[11]; scanf(\"%d%s\",&amp;a[i][j],ch); if(ch[0]=='Y')ward[i][j]=true; &#125; for(int i=1;i&lt;=m;i++)&#123; int cnt=0; for(int j=n;j&gt;=1;j--) if(ward[j][i]) s1[i][cnt]+=a[j][i]; else s1[i][++cnt]=s2[i][cnt]=s1[i][cnt-1]+a[j][i]; &#125; for(int i=1;i&lt;=m;i++) for(int j=0;j&lt;=k;j++) for(int g=0;g&lt;=n&amp;&amp;g&lt;=j;g++)&#123; dp1[i][j]=max(dp1[i][j],dp1[i-1][j-g]+s1[i][g]); if(g&gt;0) dp2[i][j]=max(dp2[i][j],dp1[i-1][j-g]+s2[i][g]); if(j-g&gt;0) dp2[i][j]=max(dp2[i][j],dp2[i-1][j-g]+s1[i][g]); &#125; printf(\"%d\\n\",dp2[m][k]); return 0;&#125;","categories":[],"tags":[{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"动态规划","slug":"动态规划","permalink":"https://dextertyw.github.io/tags/动态规划/"}]},{"title":"高精度模板","slug":"高精度模板","date":"2017-08-17T14:39:03.806Z","updated":"2017-08-24T01:23:09.426Z","comments":true,"path":"2017/08/17/高精度模板/","link":"","permalink":"https://dextertyw.github.io/2017/08/17/高精度模板/","excerpt":"来贴一波学长写的模板 感觉写的很好，对于我这种不会用指针的蒟蒻来说，通熟易懂，网上很多模板都有指针，看到都头皮发麻QAQ 关于为什么不自己写，额，应该是太菜了QAQ","text":"来贴一波学长写的模板 感觉写的很好，对于我这种不会用指针的蒟蒻来说，通熟易懂，网上很多模板都有指针，看到都头皮发麻QAQ 关于为什么不自己写，额，应该是太菜了QAQ 下面请见代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;map&gt;#define N 1000001#define M 50001#define INF 1000000000#define lowbit(x) (x&amp;(-x))#define repg(i,x) for(int i=cur[x];i;i=e[i].nt)#define rep(i,x,y) for(int i=x;i&lt;=y;i++)#define pi acos(-1)#define pb(x) push_back(x)#define eps 1e-8#define m(x) x.musing namespace std;typedef long long LL;typedef pair&lt;int,int&gt;pa;int n;/*本模板包括：1.赋值运算，支持整数以及string类赋值，用法：a=b2.基本运算，包括加减乘除取模，对单精度以及对高精度都有。3.比较函数，&gt;,&lt;,&lt;=,&gt;=,==,!=。4.外部函数包括最小公倍数，最大公约数，快速幂。 仅支持10进制（不会打压位QAQ） UPD1:高精度是可以用vector优化内存的，我不会打QAQ UPD2:最好把高精度封装到结构体里面，实际使用时，也不一定下面的要全打，要用什么打什么就行了 UPD3:看上去好麻烦，实际上，这么封装之后，你调用的时候就变的十分简单，不仅可以直接像整数一样直接运算，而且queue,stack等STL也能使用。UPD4:注意实际使用的时候高精度要放在前面例如:aa*10，而不是10*aa UPD5:学会这类板子怎么打，日后矩阵之类的就好办 \"const\"表示在这个函数中，调用的参数是不可改变的。 */struct bign&#123; long long num[510];int len; void print()&#123;//输出这个数 for(int i=len;i&gt;=1;i--)printf(\"%lld\",num[i]);printf(\"\\n\"); &#125; //定义赋值 bign()&#123;&#125; bign(string aa)&#123;*this=aa;&#125; bign(long long aa)&#123;*this=aa;&#125;//声明赋值函数 bign operator =(string aa)&#123;//string类赋值 memset(num,0,sizeof(num)); len=aa.length(); for(int i=0;i&lt;len;i++)num[i+1]=aa[len-i-1]-'0'; return *this; &#125; bign operator =(long long aa)&#123;//整数类赋值 memset(num,0,sizeof(num));len=0; long long a=aa; if(!a)len++; while(a)&#123; num[++len]=a%10;a/=10; &#125; return *this; &#125; //比较函数 bool operator &lt;(const bign&amp; a)const&#123; if(a.len&gt;len)return true; else if(a.len&lt;len)return false; for(int i=len;i&gt;=1;i--)&#123; if(a.num[i]&gt;num[i])return true; else if(a.num[i]&lt;num[i])return false; &#125; return false; &#125; bool operator &gt;(const bign&amp; a)const&#123; if(a.len&lt;len)return true; else if(a.len&gt;len)return false; for(int i=len;i&gt;=1;i--)&#123; if(a.num[i]&lt;num[i])return true; else if(a.num[i]&gt;num[i])return false; &#125; return false; &#125; bool operator ==(const bign&amp; a)const&#123; if(a.len!=len)return false; for(int i=len;i&gt;=1;i--)&#123; if(num[i]!=a.num[i])return false; &#125; return true; &#125; bool operator &lt;=(const bign&amp; a)const&#123;return *this&lt;a||*this==a;&#125; bool operator &gt;=(const bign&amp; a)const&#123;return *this&gt;a||*this==a;&#125; bool operator !=(const bign&amp; a)const&#123;return !(*this==a);&#125; //进位以及退位 void carry()&#123; for(int i=1;i&lt;len;i++)&#123;num[i+1]+=num[i]/10;num[i]%=10;&#125; while(num[len]&gt;=10)&#123;num[len+1]+=num[len]/10;num[len]%=10;len++;&#125; &#125; void decomposition()&#123; for(int i=1;i&lt;len;i++) if(num[i]&lt;0)&#123; num[i+1]--; num[i]+=10; &#125; while(!num[len]&amp;&amp;len)len--; if(!len)*this=0; &#125; //加法 bign operator +(const long long&amp; x)const&#123;//高精度加整数 bign c;c=*this; c.num[1]+=x; c.carry(); return c; &#125; bign operator +=(const long long&amp; x)&#123; *this=*this+x;return *this; &#125; bign operator +(const bign&amp; x)const&#123;//高精度加高精度 bign c=*this; c.len=max(len,x.len); for(int i=1;i&lt;=c.len;i++)c.num[i]+=x.num[i]; c.carry(); return c; &#125; bign operator +=(const bign&amp; x)&#123; *this=*this+x;return *this; &#125; //减法 bign operator -(const long long&amp; x)const&#123;//高精度减整数 bign c=*this; c.num[1]-=x; c.decomposition(); return c; &#125; bign operator -=(const long long&amp; x)&#123; *this=*this-x;return *this; &#125; bign operator -(const bign&amp; x)const&#123;//高精度减高精度 bign c=*this; c.len=max(len,x.len); for(int i=1;i&lt;=c.len;i++)c.num[i]-=x.num[i]; c.decomposition(); return c; &#125; bign operator -=(const bign&amp; x)&#123; *this=*this-x;return *this; &#125; //乘法 bign operator *(const long long &amp;x)const&#123;//高精度乘整数 bign c=*this; for(int i=1;i&lt;=len;i++)c.num[i]*=x; c.carry(); return c; &#125; bign operator *=(const long long&amp; x)&#123; *this=*this*x;return *this; &#125; bign operator *(const bign x)const&#123;//高精度乘高精度 bign c=0; for(int i=1;i&lt;=len;i++)&#123; for(int j=1;j&lt;=x.len;j++)c.num[i+j-1]+=num[i]*x.num[j]; &#125; c.len=200; while(!c.num[c.len]&amp;&amp;c.len&gt;1)c.len--; c.carry(); return c; &#125; bign operator *=(const bign&amp; x)&#123; *this=*this*x;return *this; &#125; //除法 bign operator /(const long long&amp; x)&#123;//高精度除整数 bign c=0; long long now=0; for(int i=len;i&gt;=1;i--)&#123; now=now*10+num[i]; c.num[i]=now/x;now%=x; &#125;c.len=len; c.decomposition(); return c; &#125; bign operator /=(const long long&amp; x)&#123; *this=*this/x;return *this; &#125; bign operator /(const bign&amp; x)const&#123;//高精度除高精度 bign a=0,rtn=0; for(int i=len;i&gt;=1;i--)&#123; a=a*10+num[i];int cnt=0; while(a&gt;=x)&#123; a-=x;cnt++; &#125; rtn.num[i]=cnt; &#125;rtn.len=len; rtn.decomposition(); return rtn; &#125; bign operator /=(const bign&amp; x)&#123; *this=*this/x;return *this; &#125; //取模 bign operator %(const long long&amp; x)const&#123;//高精度取模整数 long long now=0; for(int i=len;i&gt;=1;i--)&#123; now=now*10+num[i]; now%=x; &#125; return bign(now); &#125; bign operator %=(const long long&amp; x)&#123; *this=*this%x;return *this; &#125; bign operator %(const bign&amp; x)const&#123;//高精度取模高精度 bign a=0; for(int i=len;i&gt;=1;i--)&#123; a=a*10+num[i]; while(a&gt;=x)a-=x; &#125; return a; &#125; bign operator %=(const bign&amp; x)&#123; *this=*this%x;return *this; &#125;&#125;f[110]; bign gcd(bign x,bign y)&#123;//最大公约数 if(y==bign(0))return x; else return gcd(y,x%y);&#125; bign lcm(bign x,bign y)&#123;//最小公倍数 if(x&lt;0)x*=-1;if(y&lt;0)y*=-1; bign c=x*y; return c/gcd(x,y);&#125; bign sqrt(bign x)&#123;//开方 x.len+=x.len%2; bign now=0,last=0; for(int i=x.len;i;i-=2)&#123; now=now*100+x.num[i]*10+x.num[i-1]; int cnt=0;bign tmp=0; while(tmp+last*20+cnt*2+1&lt;=now)&#123; tmp+=last*20+cnt*2+1;cnt++; &#125; now-=tmp;last=last*10+cnt; &#125; return last;&#125;int main()&#123;#ifdef WK freopen(\"D:\\\\in.txt\",\"r\",stdin); freopen(\"D:\\\\out.txt\",\"w\",stdout);#endif f[1]=1; for(int i=2;i&lt;=100;i++)f[i]=f[i-1]*3-f[i-2]+2; while(scanf(\"%d\",&amp;n)!=EOF)f[n].print(); return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://dextertyw.github.io/tags/模板/"},{"name":"高精度","slug":"高精度","permalink":"https://dextertyw.github.io/tags/高精度/"}]},{"title":"Leftist Tree","slug":"左偏树模板","date":"2017-08-16T07:13:29.414Z","updated":"2017-08-16T07:12:16.628Z","comments":true,"path":"2017/08/16/左偏树模板/","link":"","permalink":"https://dextertyw.github.io/2017/08/16/左偏树模板/","excerpt":"刚刚学的左偏树，可能是可并堆里面最简单的了。模板是用来A洛谷里面的同名模板题，有兴趣可以去看看。还是比较重要的数据结构23333。 传送门直接上代码吧，有注释。","text":"刚刚学的左偏树，可能是可并堆里面最简单的了。模板是用来A洛谷里面的同名模板题，有兴趣可以去看看。还是比较重要的数据结构23333。 传送门直接上代码吧，有注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define INF 247483647#define N 3000100using namespace std;int read() &#123; int rtn = 0; char ch = getchar(); while (!isdigit(ch))ch = getchar(); while (isdigit(ch))rtn = rtn * 10 + ch - '0', ch = getchar(); return rtn;&#125;struct node &#123; int l, r, w, d, fa;&#125; heap[N];int n, m;int mergef(int x, int y) &#123; if (!x || !y)return x + y; if (heap[x].w &gt; heap[y].w || heap[x].w == heap[y].w &amp;&amp; x &gt; y)//维护小根堆,后半句纯属题目需要 swap(x, y); heap[x].r = mergef(y, heap[x].r);//把另外一个树挂到右子树上,此时的右子树深度较小 heap[heap[x].r].fa = x;//维护父节点的值 if (heap[heap[x].l].d &lt; heap[heap[x].r].d)//保证左子树比右子树更深 swap(heap[x].l, heap[x].r); if (heap[x].r)heap[x].d = heap[heap[x].r].d + 1;//由于左偏树的右子树离根节点更近,所以他的dis由右子树决定 else heap[x].d = 0;//定义没有右子树的节点dis为零 return x;//返回合并之后的新根结点&#125;int pop(int x) &#123; int l = heap[x].l, r = heap[x].r; heap[x].l = heap[x].r = heap[x].w = -INF; heap[l].fa = l, heap[r].fa = r; return heap[x].fa = mergef(l, r);//由于很多其他节点的fa值没有改变,更改父节点&#125;int findf(int x) &#123; if (heap[x].fa == x)return x; return heap[x].fa = findf(heap[x].fa);&#125;void Insert(int x) &#123; heap[x].w = read(), heap[x].d = 0, heap[x].fa = x;&#125;int main() &#123; n = read(), m = read(); heap[0].d = -1; for (int i = 1; i &lt;= n; i++)Insert(i); while (m--) &#123; int opt = read(); if (opt == 1) &#123; int x = read(), y = read(); if (heap[x].w == -INF || heap[y].w == -INF)continue; int fx = findf(x), fy = findf(y); if (fx != fy)mergef(fx, fy); &#125; if (opt == 2) &#123; int x = read(); if (heap[x].w == -INF) &#123; printf(\"-1\\n\"); continue; &#125; printf(\"%d\\n\", heap[findf(x)].w); pop(findf(x)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"左偏树","slug":"左偏树","permalink":"https://dextertyw.github.io/tags/左偏树/"},{"name":"模板","slug":"模板","permalink":"https://dextertyw.github.io/tags/模板/"}]},{"title":"noip模拟赛2017.7.28","slug":"[noip2017.7.28模拟赛]","date":"2017-07-28T06:10:40.574Z","updated":"2017-07-28T06:16:58.330Z","comments":true,"path":"2017/07/28/[noip2017.7.28模拟赛]/","link":"","permalink":"https://dextertyw.github.io/2017/07/28/[noip2017.7.28模拟赛]/","excerpt":"题目名称 九九归一 LCA 的统计 四驱兄弟 目录 mulone lcastat letsandgo 可执行文件名 mulone lcastat letsandgo 每个测试点时限 1s 1s 1s 内存限制 128M 128M 128M 测试点数目 10 10 10 每个测试点分值 10 10 10 是否有部分分 无 无 无 题目类型 传统 传统 传统","text":"题目名称 九九归一 LCA 的统计 四驱兄弟 目录 mulone lcastat letsandgo 可执行文件名 mulone lcastat letsandgo 每个测试点时限 1s 1s 1s 内存限制 128M 128M 128M 测试点数目 10 10 10 每个测试点分值 10 10 10 是否有部分分 无 无 无 题目类型 传统 传统 传统 九九归一【问题描述】萌蛋在练习模𝑛意义下的乘法时发现，总有一些数，在自乘若干次以后，会 变成 1。例如𝑛 = 7，那么5 × 5 𝑚𝑜𝑑 7 = 4,4 × 5 𝑚𝑜𝑑 7 = 6,6 × 5 𝑚𝑜𝑑 7 = 2,2 × 5 𝑚𝑜𝑑 7 = 3,3 × 5 𝑚𝑜𝑑 7 = 1。如果继续乘下去，就会陷入循环当中。 萌蛋还发现，这个循环的长度经常会是φ(𝑛)，即小于𝑛且与𝑛互质的正整数 的个数。例如，φ(7) = 6，而上述循环的长度也是 6，因为 5,4,6,2,3,1 共有 6 个 数。 再如𝑛 = 6，那么5 × 5 𝑚𝑜𝑑 6 = 1。这个循环的长度很短，只有 2，而恰好 φ(6) = 2。 然而，对于某些情况，虽然循环的长度可以是φ(𝑛)，但存在比φ(𝑛)更小的长 度：例如𝑛 = 7，而2 × 2 𝑚𝑜𝑑 7 = 4,4 × 2 𝑚𝑜𝑑 7 = 1，循环的长度只有 3。当然， 6 也可以是一个循环的长度。 假设已知了𝑛，我们称数𝑎神奇的，当且仅当关于数𝑎的循环长度可以是φ(𝑛)， 而且不存在比φ(𝑛)更小长度的循环。例如对于𝑛 = 7，5 是神奇的，而 2 不是神 奇的。 现在给出𝑛和𝑞次询问，每次询问给出𝑎，问𝑎是否是神奇的。 【输入文件】第一行两个整数𝑛 𝑞。 第二行有𝑞个整数，每个表示一个𝑎。【输出文件】 输出𝑞个字符，1 表示这个数是神奇的，0 表示这个数不是神奇的。 【输入样例】7 3 5 2 0 【输出样例】100 【数据规模和约定】对于 30%的数据，𝑛 ≤ 1,000。对于 60%的数据，𝑛 ≤ 100,000。对于 80%的数据，𝑛 ≤ 1,000,000。对于 100%的数据，𝑛 ≤ 10,000,000,𝑞 ≤ 100,000,0 ≤ 𝑎 &lt; 𝑛。 Solution和昨天的哪一题有点像，还是比较裸的，题目的要求已经说的很清楚了，要求且满足任意一个φ(𝑛)的因子不满足上述式子即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define LL long longusing namespace std;int n,q,phin;bool flag[10000010];int phi[10000010],prime[10000010],Div[1000010];void Pre_Phi()&#123; for(int i=2;i&lt;=10000010;i++) &#123; if(!flag[i])prime[++prime[0]]=i,phi[i]=i-1; for(int j=1;j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;=10000000;j++) &#123; flag[i*prime[j]]=true; phi[i*prime[j]]=phi[i]*(prime[j]-1); if(i%prime[j]==0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; &#125; &#125;&#125;void Pre_Check()&#123; for(int i=2;i&lt;=sqrt(phin);i++)&#123; if(phin%i==0) Div[++Div[0]]=i,Div[++Div[0]]=phin/i; &#125;&#125;int quickpow(int x,int y)&#123; int rtn=1; while(y) &#123; if(y&amp;1)rtn=((LL)rtn*x)%n; x=((LL)x*x)%n; y&gt;&gt;=1; &#125; return rtn%n;&#125; int main()&#123; freopen(\"mulone.in\",\"r\",stdin); freopen(\"mulone.out\",\"w\",stdout); Pre_Phi(); scanf(\"%d%d\",&amp;n,&amp;q); phin=phi[n]; Pre_Check(); while(q--) &#123; int a,f=0; scanf(\"%d\",&amp;a); for(int i=1;i&lt;=Div[0];i++) &#123; int d=Div[i]; int c=quickpow(a,d); if(c==1)&#123; printf(\"0\"); f=1; break; &#125; &#125; if(f==0&amp;&amp;quickpow(a,phin)==1)printf(\"1\"),f=1; if(f==0)printf(\"0\"); &#125; return 0;&#125; /*7 3 5 2 0 */ LCA 的统计【问题描述】萌蛋有一棵𝑛个节点的有根树，其根节点为 1。除此之外，节点𝑖的父节点 为𝑝𝑖。每个点上都有一个权值，节点𝑖的权值是𝑤𝑖。 萌蛋知道你一定知道什么叫做祖先（从根到某个点的路径上的每个点都是 这个点的祖先，包括它本身），也一定知道什么叫做最近公共祖先（两个点的最 近公共祖先是某个点，这个点同时是两个点的祖先，且离根最远）。 现在给出这棵树，你需要求出： 其中𝐿𝐶𝐴(𝑖,𝑗)表示点𝑖与点𝑗的最近公共祖先。 由于答案可能很大，你只需要输出它对 1,000,000,007 取模的结果。 【输入文件】第一行为两个整数𝑛 𝑤1。 第二行到第𝑛行，第𝑖行有两个整数𝑝𝑖 𝑤𝑖。【输出文件】 输出只有一行，为一个整数，表示所求答案对 1,000,000,007 取模的结果。 【输入样例】2 21 1 【输出样例】17 【样例解释】1 × 1 × 1 + 1 × 2 × 2 + 2 × 1 × 2 + 2 × 2 × 2 = 17。 【数据规模和约定】对于30%的数据，𝑛 ≤ 100,𝑤𝑖 ≤ 10。对于 60%的数据，𝑛 ≤ 1,000,𝑤𝑖 ≤ 1,000。对于 100%的数据，1 ≤ 𝑛 ≤ 100,000,0 ≤ 𝑤𝑖 ≤ 1,000,000,000,1 ≤ 𝑝𝑖 &lt; 𝑖。 Solution树上dp，因为这道题今天ak失败,是菜啊，考虑一个点作为LCA的情况，根据题目给出的式子有三种情况：1.i,j,k均为一个点，那么直接^3;2.i,j重合,他的所有儿子的都对答案有贡献，别忘记乘二;3.最麻烦的是i,j分别在两个不同的子树中，考虑一个二叉树，编号从1~7,当1是LCA时，你可以手动枚举一下，然后合并什么的，就可得到一个式子:ans+=w1(w2+w4+w5)(w3+w6+w7)。那么就应该做出一个子树和，便于统计。对于不是二叉树的，依旧可以通过他的子树统计，统计方法枚举一个儿子，他具有和其他儿子配对的可能性，然后用是s[k]-s[kk]就得到了所有其他儿子的配对数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define mod 1000000007#define LL long longusing namespace std;int cnt,n,w1,p[100010];LL w[100010],s[100010],ans=0;struct node&#123; int a,b,nt;&#125;e[1000010];void add(int x,int y)&#123; cnt++; e[cnt].a=x,e[cnt].b=y,e[cnt].nt=p[x],p[x]=cnt;&#125;void dfs(int k)&#123; ans=(ans+((w[k]*w[k])%mod)*w[k]%mod)%mod; s[k]=w[k]; for(int i=p[k];i;i=e[i].nt) &#123; int kk=e[i].b; dfs(kk); ans=(ans+((w[k]*w[k])%mod*s[kk])%mod*2%mod)%mod; s[k]=(s[k]+s[kk])%mod; &#125; for(int i=p[k];i;i=e[i].nt) &#123; int kk=e[i].b; ans=(ans+((w[k]*s[kk])%mod*(s[k]+mod-w[k]-s[kk])%mod)%mod)%mod; &#125; return;&#125;int main()&#123; freopen(\"lcastat.in\",\"r\",stdin); freopen(\"lcastat.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;w[1]); for(int i=2;i&lt;=n;i++) &#123; int fa; scanf(\"%d%d\",&amp;fa,&amp;w[i]); add(fa,i); &#125; dfs(1); printf(\"%lld\\n\",ans%mod); return 0;&#125; 四驱兄弟【问题描述】如果你和萌蛋一样，也看过《四驱兄弟》，你或许会记得，有一局比赛十分 特别，只按照 5 个人中的第 4 名计算成绩。 现在我们将问题扩展一下：一共有𝑛个队员，只按照其中的第𝑘名计算成 绩。而赛车的规则也有所不同：一共有𝑚个赛车，每个赛车装配着 2 个 GP 晶 片的终端，且第𝑖个赛车预期到达终点的时间为𝑎𝑖。（注：不同赛车上的终端可 以对应着相同的 GP 晶片，但不会 2 个都相同；任何赛车上的 2 个终端对应的 GP 晶片都是不同的） 比赛开始时，𝑛个队员依次选择自己的赛车。对于每个队员，他可以选择开 启 GP 晶片功能或不开启。如果开启，那么 2 个终端对应的 GP 晶片就会建立连 接，且这个赛车的比赛用时就是预期时间𝑎𝑖；如果不开启，那么 GP 晶片不会 建立连接，但是这个赛车的比赛用时将会非常长（可以认为是无穷）。甚至，他 可以放弃比赛，这样他不会占用任何赛车，但是当然比赛用时也会被认为是无 穷。 任何时候，一旦存在若干个（至少 3 个）晶片 A,B,C,…,X 满足：A 与 B 建 立了连接，B 与 C 建立了连接，……，X 与 A 建立了连接（即形成了循环连接 的情况） ，那么处理系统就会崩溃。这是非常可怕的，我们宁可让比赛用时变为 无穷也不能让系统崩溃。 现在给出队员和赛车的信息，请输出最优情况下的成绩（即第𝑘小的比赛时 间的最小值）。 为了增大难度，𝑘并不是给出的，而是你需要对于1 ≤ 𝑘 ≤ 𝑛的所 有的𝑘输出答案。 【输入文件】第一行为两个整数𝑛 𝑚。 接下来𝑚行，每行描述了一个赛车，格式为空格隔开的一个整数和两个字符 串，分别是𝑎𝑖和它的两个终端对应的 GP 晶片名。 【输出文件】𝑛行，每行一个整数，第𝑖行表示𝑖 = 𝑘时的答案。特别地，如果答案是无穷， 输出 INF。 【输入样例】3 395 GP_1 GP_2100 GP_1 gp@3100 gp@3 GP_2 Solution打的舒舒服服，是开始看这道题的时候，就感觉到了这个系列赛的典型特点，题目背景是什么鬼？？强行四驱车一波….吐槽完毕，还是比较裸的一道题，都已经说了无环，以我现在这个知识水平也就最小生成树了.还有什么hash 离散化的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define ULL unsigned long long#define LL long long using namespace std;struct node&#123; ULL a,b; LL w; int gp1,gp2; friend bool operator &lt; (node a,node b)&#123; return a.w&lt;b.w; &#125;&#125;car[100010];char gp[2][100];int fa[100010];ULL c[200010];int findf(int x)&#123; if(fa[x]==x)return fa[x]; else return fa[x]=findf(fa[x]);&#125;void mergef(int x,int y)&#123; int tx=findf(x),ty=findf(y); fa[tx]=ty;&#125;int main()&#123; freopen(\"letsandgo.in\",\"r\",stdin); freopen(\"letsandgo.out\",\"w\",stdout); int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf(\"%lld\",&amp;car[i].w); scanf(\"%s%s\",gp[0],gp[1]); ULL gp1=0,gp2=0; int len=strlen(gp[0]); for(int j=0;j&lt;len;j++)gp1=gp1*255+gp[0][j]; len=strlen(gp[1]); for(int j=0;j&lt;len;j++)gp2=gp2*255+gp[1][j]; c[++c[0]]=gp1; c[++c[0]]=gp2; car[i].a=gp1,car[i].b=gp2; &#125; sort(car+1,car+1+m); sort(c+1,c+c[0]+1); int tot=0; for(int i=1;i&lt;=c[0];i++)if(c[i]!=c[i-1])c[++tot]=c[i]; for(int i=1;i&lt;=m;i++) &#123; ULL x=car[i].a,y=car[i].b; int g1=lower_bound(c+1,c+1+tot,x)-c; int g2=lower_bound(c+1,c+1+tot,y)-c; car[i].gp1=g1,car[i].gp2=g2; &#125; for(int i=1;i&lt;=tot;i++)fa[i]=i; for(int i=1;i&lt;=m&amp;&amp;n&gt;0;i++) &#123; if(findf(car[i].gp1)!=findf(car[i].gp2)) &#123; mergef(car[i].gp1,car[i].gp2); printf(\"%lld\\n\",car[i].w); n--; &#125; &#125; while(n--) &#123; printf(\"INF\\n\"); &#125; //printf(\"%d\",(sizeof(car)+sizeof(fa)+sizeof(c))/1024/1024); return 0;&#125;/*3 3 95 GP_1 GP_2 100 GP_1 gp@3 100 gp@3 GP_2 10 10100 a b165 asd df98 sdg gsfd12 fsa er948 stf th126 sdf hg16 srdy gd546 fgh ty46 dr jgh945 ah ty*/","categories":[],"tags":[{"name":"数学之美","slug":"数学之美","permalink":"https://dextertyw.github.io/tags/数学之美/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"hash","slug":"hash","permalink":"https://dextertyw.github.io/tags/hash/"},{"name":"树上dfs","slug":"树上dfs","permalink":"https://dextertyw.github.io/tags/树上dfs/"}]},{"title":"noip模拟赛2017.7.27","slug":"[noip模拟赛2017.7.27]","date":"2017-07-27T10:40:35.981Z","updated":"2017-07-27T10:48:22.054Z","comments":true,"path":"2017/07/27/[noip模拟赛2017.7.27]/","link":"","permalink":"https://dextertyw.github.io/2017/07/27/[noip模拟赛2017.7.27]/","excerpt":"Streaming #5 (NOIP 模拟赛 Day 1) 题目名称 珠 免农 高维网络 目录 beads rabit cube 可执行文件名 beads rabit cube 输入文件名 标准输入 输出文件名 标准输出 每个测试点时限 1s 1s 1s 内存限制 128M 128M 128M 测试点数目 10 10 10 每个测试点分值 10 10 10 是否有部分分 无 无 无 题目类型 传统 传统 传统","text":"Streaming #5 (NOIP 模拟赛 Day 1) 题目名称 珠 免农 高维网络 目录 beads rabit cube 可执行文件名 beads rabit cube 输入文件名 标准输入 输出文件名 标准输出 每个测试点时限 1s 1s 1s 内存限制 128M 128M 128M 测试点数目 10 10 10 每个测试点分值 10 10 10 是否有部分分 无 无 无 题目类型 传统 传统 传统 特别提示：评测在 Linux 下进行，C/C++语言开启-O2 优化开关，Pascal语言开启-O1 优化开关。 珠【问题描述】萌蛋有𝑛颗珠子，每一颗珠子都写有一个数字。萌蛋把它们用线串成了环。 我们称一个数字串是有趣的，当且仅当它的第 1 位是 2，且除了第 1 位以外 的每一位都是 3。例如，2，233，2333333 都是有趣的数字串。 现在，你可以从这串珠子的任意一颗开始读，沿着顺时针或逆时针方向，到 任意一颗珠子停止。这样，你就可以读出一个数字串来。 萌蛋想知道，所有能读出的有趣的数字串当中，最长的是哪一个数字串。当 然，你也可能读不出任何一个有趣的数字串，你也需要对这种情况做出判断。 【输入文件】输入只有一行，是一个数字串。这是从这串珠子的某一颗开始，顺时针读取 恰好一圈得到的。 【输出文件】 输出只有一行，是能读出的最长有趣的数字串。特殊地，如果找不到任何有 趣的数字串，应输出“TvT”（不含引号）。 【输入样例 1】323 【输出样例 1】233 【输入样例 2】333 【输出样例 2】TvT 【数据规模和约定】对于20%的数据，𝑛 ≤ 3。对于 40%的数据，𝑛 ≤ 100。对于 60%的数据，𝑛 ≤ 1,000。另有 20%的数据，输入的数字串中不含 3。对于 100%的数据，𝑛 ≤ 100,000。 Solution签到题，从2开始分两头扫描，O(n)结束。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;char ch[1000100];int cnt=0,ans=0,pos,flag;int main()&#123; freopen(\"beads.in\",\"r\",stdin); freopen(\"beads.out\",\"w\",stdout); scanf(\"%s\",ch+1); int len=strlen(ch+1); for(int i=1;i&lt;=len;i++)ch[i+len]=ch[i]; for(int i=1;i&lt;=len;i++) &#123; cnt=0; if(ch[i]!='2')continue; cnt++; int j=i+1; while(true) &#123; if(ch[j]=='3')cnt++,j++; else break; &#125; if(cnt&gt;ans)ans=cnt,pos=i,flag=1; &#125; for(int i=len*2;i&gt;len;i--) &#123; cnt=0; if(ch[i]!='2')continue; cnt++; int j=i-1; while(true) &#123; if(ch[j]=='3')cnt++,j--; else break; &#125; if(cnt&gt;ans)ans=cnt,pos=i,flag=2; &#125; if(flag==1)&#123; for(int i=pos;i;i++) &#123; if(i!=pos&amp;&amp;ch[i]!='3')break; else printf(\"%c\",ch[i]); &#125; &#125; if(flag==2)&#123; for(int i=pos;i;i--) &#123; if(i!=pos&amp;&amp;ch[i]!='3')break; else printf(\"%c\",ch[i]); &#125; &#125; if(flag==0)printf(\"TvT\"); return 0;&#125; 免农【问题描述】（如果你想更好地理解本题，请先阅读 NOI2011 第一试“兔农”一题） 萌蛋近年收入不景气，正在她发愁如何能多赚点钱时，她听到隔壁的小朋友 在讨论免子繁殖的问题。（注：免子是一种简单的单细胞生物） 问题是这样的：时刻 0 有 2 只刚出生的免子。每一时刻，每只免子都会分裂 成为 2 只免子。问时刻𝑛共有多少只免子？ 聪明的你可能已经发现，时刻𝑛的免子数正好是第𝑛 + 1个 2 的幂次。萌蛋不 懂什么叫幂，但她也发现了规律：时刻𝑛 + 1的免子数等于时刻𝑛的免子数的 2 倍。 前几个时刻（从 0 开始）的免子数依次为： 2 4 8 16 32 64 128 256 512 … 萌蛋发现越到后面免子数增长的越快，期待养免子一定能赚大钱，于是萌蛋 在时刻 0 买了 2 只免子开始培养。 每天，萌蛋都要给免子们提供营养。免子的培养基非常特别，每𝑘只免子占 据一个培养基，最后剩下的不足𝑘只占据一个培养基。由于免子特别害怕孤独， 如果某个培养基只有 1 只免子，这只免子就会很快死掉。 然而，每个时刻的免子数仍然是可以计算的。例如，当𝑘 = 7时，前几个时 刻（从 0 开始）的免子数依次为： 2 4 7 14 28 56 112 224 448 … 给定𝑛，你能帮助萌蛋计算时刻𝑛她有多少只免子么？由于答案可能非常大， 你只需要告诉萌蛋时刻𝑛的免子只数对𝑝的余数即可。 【输入文件】 输入只有一行，包含三个整数𝑛 𝑘 𝑝。 【输出文件】 输出只有一行，为一个整数，表示时刻𝑛的免子只数对𝑝的余数。 【输入样例】6 7 10086 【输出样例】112 【数据规模和约定】对于 30%的数据，𝑛 ≤ 1,000,000。另有 30%的数据，𝑘是𝑝的正整数倍。对于 100%的数据， 𝑛 ≤ 1,000,000,000,2 ≤ 𝑘 ≤ 1,000,000,1 ≤ 𝑝 ≤ 1,000,000。 Solution这道题也很傻逼吧。md2011nNOI那一题不知道比这高到哪里去了，还有助于理解，迷醉。很明显第一次死亡之后，免子就不会再死了，所以只要求出免子什么时候第一次死。又很明显：证明了枚举次数不会超过k次。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int n,k,p;int Quick_Pow(int x,int y,int mod)&#123; int rtn=1; while(y) &#123; if(y&amp;1)rtn=((1ll)*rtn*x)%mod; x=((1ll)*x*x)%mod; y&gt;&gt;=1; &#125; return rtn;&#125;void Pre_Check()&#123; if(k%2==0)&#123; printf(\"%d\",Quick_Pow(2,n+1,p)); exit(0); &#125;&#125;int main()&#123; freopen(\"rabit.in\",\"r\",stdin); freopen(\"rabit.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;n,&amp;k,&amp;p); Pre_Check(); int cnt=1,pos=-1; for(int i=0;i&lt;=n;i++)&#123; cnt=(cnt&lt;&lt;1)%k; if(cnt==1)&#123; pos=i; break; &#125; &#125; if(pos&gt;=0)printf(\"%d\",((1ll)*(Quick_Pow(2,pos+1,p)-1+p)%p*Quick_Pow(2,n-pos,p))%p); else printf(\"%d\",Quick_Pow(2,n+1,p)); return 0;&#125;/*printf(\"%d\",((1ll)**Quick_Pow(2,n-i,p))%p);1000000000 1000009 1000007*/ 高维网络【问题描述】现在有一个𝑑维的坐标网格，其中第𝑖维坐标的范围是[0,𝑎𝑖]。 在这个范围内建立一个有向图：我们把范围内的每个整点（每一维坐标均为 整数的点）当做图上的顶点。设点𝐴(0,0,⋯,0),𝐵(𝑎1,𝑎2,⋯,𝑎𝑑)。 对于范围内的点(𝑥1,𝑥2,⋯,𝑥𝑑)，它会向以下这些点（如果目标点在范围内）： (𝑥1 + 1,𝑥2,⋯,𝑥𝑑),(𝑥1,𝑥2 + 1,⋯,𝑥𝑑),⋯,(𝑥1,𝑥2,⋯,𝑥𝑑 + 1)连有向边。 现在从点𝐴到点𝐵会有若干条路径，路径的条数可以十分简单地算出。然而 不幸的是，范围内有𝑝个点被破坏了（点𝐴和点𝐵不会被破坏），其中第𝑖个点的坐 标为(𝑥𝑖,1,𝑥𝑖,2,⋯,𝑥𝑖,𝑑)。你需要算出从点𝐴到点B剩余的路径条数。 由于答案可能很大，你只需要输出它对1,000,000,007取模的结果。 【输入文件】第一行为两个整数𝑑 𝑝。 第二行为𝑑个整数，其中第𝑖个数是𝑎𝑖。 接下来𝑝行，每行𝑑个整数，其中第𝑖行第𝑗个数是𝑥𝑖,𝑗。 【输出文件】一个整数，表示从点𝐴到点𝐵剩余的路径条数对1,000,000,007取模的结果。 【输入样例】2 12 11 0【输出样例】1 【样例解释】如图所示，当删掉点(1,0)后，从点𝐴到点𝐵的 3 条路径只剩下了 1 条。 【数据规模和约定】 Solution这道题还是一道好题，暴力拿了60，也只能拿六十。首先我们可以考虑如果没有限制点的存在。也就是说每个维的状态从0到ai有多少种方案。运用一些组合数学的知识可以知道（然而我并不会证明）：对于整道题我们再来使用dp，记dp[i]来表示从起点(0,0)走到第i个限制点的合法方案数，如果到达了i那么后面的所有路径均不合法直接运用我们上面推的算法就可以得到方案数,用A到B的总方案数减去两者的乘积即可。那么我们注意到这种方法可以对所有情况进行处理，关键在于我们如何得到dp[i]的值，那么其实已经说的很显然了，我们可以把i当成终点进行分治，所有在其左下方的点都要被统计以上。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define LL long long#define mod 1000000007using namespace std;int d,p[510][510],P;LL fac[10000007],inv[100007],a[110],dp[10000007]; LL Quick_Pow(LL x,LL y)&#123; LL rtn=1; while(y) &#123; if(y&amp;1)rtn=(rtn*x)%mod; x=(x*x)%mod; y&gt;&gt;=1; &#125; return rtn;&#125;void Pre()&#123; fac[0]=1;inv[0]=1; for(int i=1;i&lt;=10000007;i++) fac[i]=(fac[i-1]*i)%mod; for(int i=1;i&lt;=100007;i++) inv[i]=Quick_Pow(fac[i],mod-2);&#125;LL Count(int x,int y)&#123; LL rtn=1,sum=0; for(int i=1;i&lt;=d;i++) &#123; int dx=p[y][i]-p[x][i]; if(dx&lt;0)return -1; sum+=dx,rtn=(rtn*inv[dx])%mod; &#125; rtn=(rtn*fac[sum])%mod; return rtn;&#125; LL dfs(int pos)&#123; LL rtn=0; if(dp[pos]!=-1)return dp[pos]; rtn+=Count(0,pos); for(int i=1;i&lt;=P+1;i++)if(pos!=i) &#123; LL c=Count(i,pos); if(c==-1)continue; rtn=(rtn+mod-dfs(i)*c%mod)%mod; &#125; return dp[pos]=rtn;&#125;int main()&#123; //freopen(\"cube.in\",\"r\",stdin); //freopen(\"cube.out\",\"w\",stdout); scanf(\"%d%d\",&amp;d,&amp;P); for(int i=1;i&lt;=d;i++)scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=P;i++)for(int j=1;j&lt;=d;j++) scanf(\"%d\",&amp;p[i][j]); Pre(); for(int i=1;i&lt;=d;i++) p[0][i]=0,p[P+1][i]=a[i]; memset(dp,-1,sizeof(dp)); printf(\"%lld\",dfs(P+1)); return 0;&#125;/*2 1 2 1 1 0 */","categories":[],"tags":[{"name":"数学之美","slug":"数学之美","permalink":"https://dextertyw.github.io/tags/数学之美/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"优秀dp","slug":"优秀dp","permalink":"https://dextertyw.github.io/tags/优秀dp/"}]},{"title":"CDQ学习笔记","slug":"CDQ分治学习笔记","date":"2017-07-25T14:19:51.909Z","updated":"2017-07-25T14:53:32.017Z","comments":true,"path":"2017/07/25/CDQ分治学习笔记/","link":"","permalink":"https://dextertyw.github.io/2017/07/25/CDQ分治学习笔记/","excerpt":"CDQ 分治学习笔记学习的目的在任何一个OIer的职业生涯中，都会碰到一些繁琐的数据结构题，而现在的省选有基本是数据结构大战，可见数据结构的重要性，但是和我说的CDQ有什么关系QAQ？？？数据结构写起来，基本上就呵呵了，动不动两三百行的代码，调试时基本万念俱灰。。。（可能是我比较菜QAQ）这个时候CDQ的用处就很明显的，写起来简单，写起来简单，写起来简单！！！","text":"CDQ 分治学习笔记学习的目的在任何一个OIer的职业生涯中，都会碰到一些繁琐的数据结构题，而现在的省选有基本是数据结构大战，可见数据结构的重要性，但是和我说的CDQ有什么关系QAQ？？？数据结构写起来，基本上就呵呵了，动不动两三百行的代码，调试时基本万念俱灰。。。（可能是我比较菜QAQ）这个时候CDQ的用处就很明显的，写起来简单，写起来简单，写起来简单！！！ 算法要求与使用大前提:CDQ一定是处理离线算法，如果强制在线，还是要么暴力，要么刚数据结构。 使用：1.区间维护什么的就乱搞了，其实也用不到CDQ，但我们要清楚，区间维护其实就是维护一个二维偏序，具体做法我们稍后再说。2.CDQ的真正用处在于维护一个三维偏序，一般的做法是套用一个树状数组维护第三维。三维偏序的理解，举个例子给你很多三维坐标如(a,b,c),希望你求坐标满足:a&lt;x&amp;&amp;b&lt;y&amp;&amp;c&lt;z的点的个数有多少个； 具体实现很多前辈都说CDQ的写法与归并排序超级像，其实也真的是超级像。先说一下二维的实现：如果给你一个区间，有很多点权值，支持单点修改和区间查询。其实树状数组乱秒，考虑CDQ怎么做。对于每个操作我们必须要维护一个时间序，否则会乱套。那么考虑这么一个事实，每次修改操作一定是对后面发生的询问有影响，而我们已经将操作们按照时间排了序，分治的模型可能就出来了吧QAQ。我们递归枚举左区间和右区间，只是在合并前要多一步，考虑左区间中元素对右区间的影响：记操作的区间的左端点是x，右端点是y;那么满足 q[i].x&lt;q[j].x都会对查询有影响，注意我们查询的是两个前缀和：sum[x-1],sum[y];那么我们很清楚查询到x-1时，对这次区间询问的答案应该是减去sum[x-1]的，而到y时，便是加上sum[y]。好了可以总结一下，CDQ的基本思路就是保证左区间与右区间的修改和查询独立协调后，处理左区间对右区间的影响。如果左区间的所有元素都不满足于修改条件（见上），那么说明右区间的查询部分是不受限制的，可以直接更新答案。好了差不多就这样了，如果还是不清楚的话，可以在看几篇博客，知识点不可能看一篇文章就能学会的。 三维偏序三维偏序其实是对二位偏序的拓展。我们可以保证默认序时间序是有序的，我们也能保证第二维在维护的时候可以有序，但是第三维我们只能放弃，否则会冲突。这时候我们可以借助一个简单的数据结构，比如说树状数组来维护。 先放一道入门题比模板题多一点点操作在于只用容斥把查询稍微转化一下就行了因为有些查询是对答案有利，有些不是，所以定义的时候可以应入一个w变量=1||-1来记录状态。贴一波同组写的题解 传送门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define lowbit(x) (x&amp;(-x))using namespace std;int s,w,sz[2000100];struct node&#123; int type,x,y,num,w; node(int _type=0,int _x=0,int _y=0,int _num=0,int _w=0)&#123; type=_type,x=_x,y=_y,num=_num,w=_w; &#125; friend bool operator &lt;= (node a,node b)&#123; return a.x&lt;=b.x; &#125;&#125;q[500500],tmp[2000100];int cnt,tot,ans[100010];void update(int x,int y)&#123; for(int i=x;i&lt;=w;i+=lowbit(i)) sz[i]+=y;&#125;int query(int x)&#123; int rtn=0; for(int i=x;i;i-=lowbit(i)) rtn+=sz[i]; return rtn;&#125;void CDQ(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); int i=l,j=mid+1,o=0; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; if(q[i]&lt;=q[j]) &#123; if(q[i].type==1) update(q[i].y,q[i].w); tmp[o++]=q[i++]; &#125; else &#123; if(q[j].type==2) ans[q[j].num]+=query(q[j].y)*q[j].w; tmp[o++]=q[j++]; &#125; &#125; while(i&lt;=mid) &#123; if(q[i].type==1)update(q[i].y,q[i].w); tmp[o++]=q[i++]; &#125; while(j&lt;=r) &#123; if(q[j].type==2)ans[q[j].num]+=query(q[j].y)*q[j].w; tmp[o++]=q[j++]; &#125; for(int i=l;i&lt;=mid;i++) if(q[i].type==1)update(q[i].y,-q[i].w); for(int i=0;i&lt;o;i++) q[i+l]=tmp[i];&#125;int main()&#123; scanf(\"%d%d\",&amp;s,&amp;w); while(true) &#123; int x,y,x1,y1,w; int opt;scanf(\"%d\",&amp;opt); if(opt==3)break; if(opt==1)&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w); q[++cnt]=node(1,x,y,0,w); &#125; if(opt==2)&#123; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;x1,&amp;y1); q[++cnt]=node(2,x-1,y-1,++tot,1); q[++cnt]=node(2,x1,y1,tot,1); q[++cnt]=node(2,x-1,y1,tot,-1); q[++cnt]=node(2,x1,y-1,tot,-1); ans[tot]+=s*(x1-x+1)*(y1-y+1); &#125; &#125; CDQ(1,cnt); for(int i=1;i&lt;=tot;i++)printf(\"%d\\n\",ans[i]); return 0;&#125; /*0 21 1 1 12 1 1 1 13 */","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dextertyw.github.io/tags/学习笔记/"},{"name":"CDQ","slug":"CDQ","permalink":"https://dextertyw.github.io/tags/CDQ/"}]},{"title":"noip模拟赛2017.7.25","slug":"[noip模拟赛2017.7.25]","date":"2017-07-25T06:42:14.823Z","updated":"2017-07-25T07:21:29.999Z","comments":true,"path":"2017/07/25/[noip模拟赛2017.7.25]/","link":"","permalink":"https://dextertyw.github.io/2017/07/25/[noip模拟赛2017.7.25]/","excerpt":"Thinking Bear #1——NOIP 2014 提高组模拟赛竞赛时间：2014 年 8 月 17 日 18:30－22:00 中文题目名称 拆地毯 还教室 皇后游戏 英文题目名称 carpet classroom game 每个测试点时限 1 秒 1 秒 1 秒 内存限制 512MB 512MB 512MB 测试点数目 10 20 20 每个测试点分值 10 5 5 是否有部分分 否 否 否 题目类型 传统型 传统型 传统型","text":"Thinking Bear #1——NOIP 2014 提高组模拟赛竞赛时间：2014 年 8 月 17 日 18:30－22:00 中文题目名称 拆地毯 还教室 皇后游戏 英文题目名称 carpet classroom game 每个测试点时限 1 秒 1 秒 1 秒 内存限制 512MB 512MB 512MB 测试点数目 10 20 20 每个测试点分值 10 5 5 是否有部分分 否 否 否 题目类型 传统型 传统型 传统型 注意：最终测试时，将开启-O2 优化开关。Thinking Bear #1 拆地毯【引子】还记得 NOIP 2011 提高组 Day1 中的铺地毯吗？时光飞逝，光阴荏苒，三年 过去了。组织者精心准备的颁奖典礼早已结束，留下的则是被人们踩过的地毯。 请你来解决类似于铺地毯的另一个问题。 【问题描述】会场上有 n 个关键区域，不同的关键区域由 m 条无向地毯彼此连接。每条 地毯可由三个整数 u、v、w 表示，其中 u 和 v 为地毯连接的两个关键区域编号， w 为这条地毯的美丽度。 由于颁奖典礼已经结束，铺过的地毯不得不拆除。为 了贯彻勤俭节约的原则， 组织者被要求只能保留 K 条地毯，且保留的地毯构成的图中，任意可互相到达 的两点间只能有一种方式互相到达。换言之，组织者要求新图中不能有环。现在 组织者求助你，想请你帮忙算出这 K 条地毯的美丽度之和最大为多少。 【输入格式】第一行包含三个正整数 n、m、K。 接下来 m 行中每行包含三个正整数 u、v、w。 【输出格式】只包含一个正整数，表示这 K 条地毯的美丽度之和的最大值。 【样例输入】5 4 31 2 101 3 92 3 74 5 3 【样例输出】22 【样例说明】选择第 1、2、4 条地毯，美丽度之和为 10 + 9 + 3 = 22。 若选择第 1、2、3 条地毯，虽然美丽度之和可以达到 10 + 9 + 7 = 26，但这 将导致关键区域 1、2、3 构成一个环，这是题目中不允许的。Thinking Bear #1 拆地毯第 3 页 共 8 页 【数据规模与约定】所有测试点的数据规模如下：保证至 少存在一种方案使得在原图中可以选出K条边，这K条边构成的新图环。 Solution很裸的最大生成树保证选满k条边就不用担心了….1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n,m,k,fa[100100];struct node&#123; int a,b,w;&#125;e[100100];bool cmp(node a,node b)&#123; return a.w&gt;b.w;&#125;int findf(int x)&#123; if(fa[x]==x)return x; else return fa[x]=findf(fa[x]);&#125;int main()&#123; freopen(\"carpet.in\",\"r\",stdin); freopen(\"carpet.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(register int i=1;i&lt;=n;i++)&#123;fa[i]=i;&#125; for(register int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].a,&amp;e[i].b,&amp;e[i].w); sort(e+1,e+1+m,cmp); int cc=1,ans=0; while(k) &#123; int from=e[cc].a,to=e[cc].b,w=e[cc].w; int fa_from=findf(from); int fa_to=findf(to); if(fa_from!=fa_to) &#123; ans+=w; fa[fa_from]=fa_to; k--; &#125; cc++; &#125; printf(\"%d\",ans); return 0;&#125; /*5 4 31 2 10 1 3 9 2 3 7 4 5 3 */ Thinking Bear #1 还教室【引子】还记得 NOIP 2012 提高组 Day2 中的借教室吗？时光飞逝，光阴荏苒，两年 过去了，曾经借教室的同学们纷纷归还自己当初租借的教室。请你来解决类似于 借教室的另一个问题。 【问题描述】在接受借教室请求的 n 天中，第 i 天剩余的教室为 ai个。作为大学借教室服 务的负责人，你需要完成如下三种操作共 m 次： ① 第 l 天到第 r 天，每天被归还 d 个教室。 ② 询问第 l 天到第 r 天教室个数的平均数。 ③ 询问第 l 天到第 r 天教室个数的方差。 【输入格式】第一行包括两个正整数 n 和 m，其中 n 为借教室的天数，m 为操作次数。 接下来一行，共 包含 n 个整数，第 i 个整数表示第 i 天剩余教室数目为 ai个。 接下来 m 行，每行的第一个整数为操作编号（只能为 1 或 2 或 3），接下来 包含两个正整数 l 和 r，若操作编号为 1，则接下来再包含一个正整数 d。 【输出格式】对于每个操作 2 和操作 3，输出一个既约分数（分子与分母互质）表示询问 的答案（详见样例）。 若 答 案 为 0 ， 请 输出“0/1”（不含引号）。【样例输入】5 4 1 2 3 4 5 1 1 2 3 2 2 4 3 2 4 3 1 5 【样例输出】4/1 2/3 14/25Thinking Bear #1 还教室第 5 页 共 8 页 【样例说明】 【数学小贴士】 【数据规模与约定】所有测试点的数据规模如下： 对于全部测试数据满足：1 ≤ l ≤ r ≤ n，0 ≤ ai ≤ 10，1 ≤ d ≤ 3，操作 1 的数量 不超过 10%。注意：ai和 d 的范围很小及操作 1 数量很少的原因是为了保证答案 的分子不会很大，以防止答案的分子溢出 64 位整数的范围，这与题目做法无关。 Solution很裸的线段树，这些题的题面都很迷，贼尴尬的背景，既然是分数输出，那么我们肯定不是直接对答案进行维护，第一问好说仅维护一个区间和，而第二问我们可以推推公式：d代表的是区间加值，代表的是区间长度而观察到我们已经维护了区间的求和，那么再维护一个平方和就可以了QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define LL long longusing namespace std;int n,q;struct node&#123; int l,r; LL s1,s2,d;&#125;T[400100];inline int read()&#123; char c=getchar();int rtn=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;rtn=rtn*10+c-'0';c=getchar();&#125; return rtn*f;&#125;void Build_Tree(int p,int l,int r)&#123; T[p].l=l,T[p].r=r; if(l==r)return; int mid=(l+r)&gt;&gt;1; Build_Tree(p&lt;&lt;1,l,mid); Build_Tree(p&lt;&lt;1|1,mid+1,r);&#125;inline void deal(int p,int c)&#123; int ll=T[p].l,rr=T[p].r; T[p].d+=c; T[p].s2=T[p].s2+(rr-ll+1)*c*c+2*c*T[p].s1; T[p].s1=T[p].s1+(rr-ll+1)*c;&#125;inline void pushdown(int p)&#123; int ls=p&lt;&lt;1,rs=p&lt;&lt;1|1; deal(ls,T[p].d);deal(rs,T[p].d); T[p].d=0;&#125;inline void pushup(int p)&#123; T[p].s1=T[p&lt;&lt;1].s1+T[p&lt;&lt;1|1].s1; T[p].s2=T[p&lt;&lt;1].s2+T[p&lt;&lt;1|1].s2;&#125;void update(int p,int l,int r,int c)&#123; int ll=T[p].l,rr=T[p].r; if(ll==l&amp;&amp;rr==r) &#123; deal(p,c); return; &#125; pushdown(p); int mid=(ll+rr)&gt;&gt;1; if(r&lt;=mid)update(p&lt;&lt;1,l,r,c); else if(l&gt;mid)update(p&lt;&lt;1|1,l,r,c); else&#123; update(p&lt;&lt;1,l,mid,c); update(p&lt;&lt;1|1,mid+1,r,c); &#125; pushup(p);&#125;LL query_aven(int p,int l,int r)&#123; int ll=T[p].l,rr=T[p].r; if(ll==l&amp;&amp;rr==r)return T[p].s1; pushdown(p); int mid=(ll+rr)&gt;&gt;1; if(r&lt;=mid)return query_aven(p&lt;&lt;1,l,r); else if(l&gt;mid)return query_aven(p&lt;&lt;1|1,l,r); else&#123; return query_aven(p&lt;&lt;1,l,mid)+ query_aven(p&lt;&lt;1|1,mid+1,r); &#125;&#125;LL query_cha(int p,int l,int r)&#123; int ll=T[p].l,rr=T[p].r; if(ll==l&amp;&amp;rr==r)return T[p].s2; pushdown(p); int mid=(ll+rr)&gt;&gt;1; if(r&lt;=mid)return query_cha(p&lt;&lt;1,l,r); else if(l&gt;mid)return query_cha(p&lt;&lt;1|1,l,r); else&#123; return query_cha(p&lt;&lt;1,l,mid)+ query_cha(p&lt;&lt;1|1,mid+1,r); &#125;&#125;LL gcd(LL a,LL b)&#123; if(b==0)return a; else return gcd(b,a%b);&#125;void print(LL x,LL y)&#123; LL gcd_div=gcd(x,y); LL o1=x/gcd_div,o2=y/gcd_div; printf(\"%lld/%lld\\n\",o1,o2);&#125;int main()&#123; freopen(\"classroom.in\",\"r\",stdin); freopen(\"classroom.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;q); Build_Tree(1,1,n); for(register int i=1;i&lt;=n;i++)&#123;int x=read();update(1,i,i,x);&#125; while(q--) &#123; int opt=read(),from=read(),to=read(); if(opt==1) &#123; int cc=read(); update(1,from,to,cc); continue; &#125; if(opt==2) &#123; LL ans=query_aven(1,from,to),len=to-from+1; print(ans,len); continue; &#125; if(opt==3) &#123; LL ans=query_cha(1,from,to); LL x_=query_aven(1,from,to); LL len=to-from+1; print(len*ans-x_*x_,len*len); continue; &#125; &#125; return 0;&#125;/*5 4 1 2 3 4 5 1 1 2 3 2 2 4 3 2 4 3 1 5*/ Thinking Bear #1 皇后游戏【引子】还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年 过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游 戏的另一个问题。 【问题描述】皇后有 n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆 节来临，皇后决定为 n 位大臣颁发奖金，其中第 i 位大臣所获得的奖金数目为第 i－1 位大臣所获得奖金数目与前 i 位大臣左手上的数的和的较大值再加上第 i 位 大臣右手上的数。 形式化地讲：我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi， 则第 i 位大臣获得的奖金数目为 ci可以表达为：当然,吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安 排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。 注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一 位大臣的位置。 【输入格式】第一行包含一个正整数 T，表示测试数据的组数。 接下来 T 个部分，每个部分的第一行包含一个正整数 n，表示大臣的数目。 每个部分接下来 n 行中，每 行 两个正整数，分 别 为 a i 和 b i ，含 义 如 上文所述。 【输出格式】共 T 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 【样例输入 1】1 3 4 1 2 2 1 2Thinking Bear #1 皇后游戏第 7 页 共 8 页 【样例输出 1】8 【样例说明 1】按照 1、2、3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 10；按照 1、3、2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9；按照 2、1、3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9；按照 2、3、1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8；按照 3、1、2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9；按照 3、2、1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8。当按照 3、2、1 这样排列队伍时，三位大臣左右手的数分别为： (1, 2)、(2, 2)、(4, 1) 第 1 位大臣获得的奖金为 1 + 2 = 3； 第 2 位大臣获得的奖金为 max{3, 3} + 2 = 5； 第 3 为大臣获得的奖金为 max{5, 7} + 1 = 8。 【样例输入 2】2 5 85 100 95 99 76 87 60 97 79 85 12 9 68 18 45 52 61 39 83 63 67 45 99 52 54 82 100 23 54 99 94 63 100 52 68 【样例输出 2】528 902Thinking Bear #1 皇后游戏第 8 页 共 8 页 【数据规模与约定】所有测试点的数据规模如下：对于全部测试数据满足：1 ≤ ai, bi ≤ 109。 【特别提示】由于评测在 Linux 下进行，请 C++选手务必注意 Linux 系统下 rand()函数返 回值的取值范围是[0, 231). Solution这个和国王的游戏比起来可能没有高精度，但是公式个人感觉是要麻烦一些，考场上没有做出来….qwq。大概就是很普通的贪心，观察到后一个人拿的钱是在钱一个人拿的钱的基础上有所增加，我们如果能保证后面的人拿钱最少那么答案就越小，根据公式贪心，假设前i-2个人都排好队，现在要排第i-1和第i个人：（注意c的下标意义是和a，b的下标意义不一样）1.考虑第i-1个人放在前面：2.考虑第i个人放在前面：我们排序的时候只用比较那种的ci更小就可以了两个公式有公共部分，化简得到：1.2.这就是排序的标准！！当然要是想骗分的话还是比较简单的，可以选择多重排序结构，选一个最小答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;inline int read()&#123; char c=getchar();int rtn=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;rtn=rtn*10+c-'0';c=getchar();&#125; return rtn*f;&#125;LL c,sum;struct node&#123; LL l,r;&#125;p[505000];bool cmp(node a,node b)&#123; return max(a.l+a.r+b.r,a.l+b.l+b.r)&lt;max(b.l+b.r+a.r,b.l+a.l+a.r);&#125;int main()&#123; //freopen(\"game.in\",\"r\",stdin); //freopen(\"game.out\",\"w\",stdout); int T;T=read(); while(T--) &#123; c=0,sum=0; int n;n=read(); for(register int i=1;i&lt;=n;i++)p[i].l=read(),p[i].r=read(); sort(p+1,p+1+n,cmp); c=p[1].l+p[1].r;sum+=p[1].l; for(register int i=2;i&lt;=n;i++) &#123; sum+=p[i].l; c=max(c,sum)+p[i].r; &#125; printf(\"%lld\\n\",c); &#125; return 0;&#125;/*1 3 4 1 2 2 1 2 2 5 85 100 95 99 76 87 60 97 79 85 12 9 68 18 45 52 61 39 83 63 67 45 99 52 54 82 10023 54 99 9463 100 52 68*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"线段树","slug":"线段树","permalink":"https://dextertyw.github.io/tags/线段树/"},{"name":"贪心","slug":"贪心","permalink":"https://dextertyw.github.io/tags/贪心/"}]},{"title":"二维树状数组入门题","slug":"Matrix","date":"2017-07-24T11:57:35.434Z","updated":"2017-07-24T12:06:18.418Z","comments":true,"path":"2017/07/24/Matrix/","link":"","permalink":"https://dextertyw.github.io/2017/07/24/Matrix/","excerpt":"Matrix (poj 2155)传送门Time Limit: 3000MSMemory Limit: 65536KDescriptionGiven an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2). Q x y (1 &lt;= x, y &lt;= n) querys A[x, y].","text":"Matrix (poj 2155)传送门Time Limit: 3000MSMemory Limit: 65536KDescriptionGiven an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2). Q x y (1 &lt;= x, y &lt;= n) querys A[x, y]. InputThe first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case. The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above.OutputFor each querying output one line, which has an integer representing A[x, y]. There is a blank line between every two continuous test cases.Sample Input12 10C 2 1 2 2Q 2 2C 2 1 2 1Q 1 1C 1 1 2 1C 1 2 1 2C 1 1 2 2Q 1 1C 1 1 2 1Q 2 1 Sample Output1001SourcePOJ Monthly,Lou Tiancheng 题意对于一个0,1矩阵，支持左下(x1,y1)-右上(x2,y2)矩形区域内的反转，然后对单点(x,y)的查询。 Solution今天才学的二维树状数组（菜的一匹），其实看到对于一个二维区域的维护应该就能想到这类型的数据结构。那么对于单点查询，结合树状数组可想到是由差分来实现的，因为树状数组只能提取前缀和。然后对于一个二维平面如何加值，类似于一维中的s[x]+v,s[y]-v。推广到二维则有： 可以看一下这个图。 另外题面中的加大的字各位可以品尝..QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int s[2100][2100],n,q;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int y,int c)&#123; for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=n;j+=lowbit(j)) s[i][j]+=c;&#125;int query(int x,int y)&#123; int rtn=0; for(int i=x;i;i-=lowbit(i)) for(int j=y;j;j-=lowbit(j)) rtn+=s[i][j]; return rtn; &#125;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; scanf(\"%d%d\",&amp;n,&amp;q); memset(s,0,sizeof(s)); while(q--) &#123; char ch[5]; scanf(\"%s\",ch); if(ch[0]=='C') &#123; int x1,y1,x2,y2; scanf(\"%d%d%d%d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2); add(x2+1,y2+1,1); add(x1,y2+1,-1); add(x2+1,y1,-1); add(x1,y1,1); &#125; if(ch[0]=='Q') &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",query(x,y)%2); &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; /*12 10C 2 1 2 2Q 2 2C 2 1 2 1Q 1 1C 1 1 2 1C 1 2 1 2C 1 1 2 2Q 1 1C 1 1 2 1Q 2 1*/","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dextertyw.github.io/tags/树状数组/"},{"name":"数据结构","slug":"数据结构","permalink":"https://dextertyw.github.io/tags/数据结构/"},{"name":"二维","slug":"二维","permalink":"https://dextertyw.github.io/tags/二维/"}]},{"title":"noip模拟赛2017.7.22","slug":"[noip模拟赛2017.7.22]","date":"2017-07-23T06:10:22.003Z","updated":"2017-07-24T12:00:36.839Z","comments":true,"path":"2017/07/23/[noip模拟赛2017.7.22]/","link":"","permalink":"https://dextertyw.github.io/2017/07/23/[noip模拟赛2017.7.22]/","excerpt":"【试题概览】 题目名称 数7 正方形计数 速算游戏 单人纸牌 提交文件 seven.* count.* fun.* double.* 输入文件 seven.in count.in fun.in double.in 输出文件 seven.out count.out fun.out double.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB","text":"【试题概览】 题目名称 数7 正方形计数 速算游戏 单人纸牌 提交文件 seven.* count.* fun.* double.* 输入文件 seven.in count.in fun.in double.in 输出文件 seven.out count.out fun.out double.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB 1. 数7【题目描述】1337 个人排成一个圈，从 1 号人开始报数，初始的方向是 1,2,3…。如果某个人报的数是 7 的倍数或 者数字中含有 7，那么报数的方向就反一下。问报数字 X 的是哪个人？ 【输入格式】一行一个数 X 【输出格式】一行一个数表示最终报数字 X 的是哪个人。 【数据规模】对于 30%的数据，满足 X&lt;=10^6;对于 90%的数据，满足 X&lt;=10^8;对于 100%的数据，满足 X&lt;=10^9。 【输入样例】1000 【输出样例】1311 Solution首先都想到了nlogn的做法，再想直接打表，如果打表的话估计也只能过10^8 ,而且还不稳定。先想想90分怎么做，考虑到主要的时间消耗在于对%7的判断以及对是否含有7的判断，与其取膜和分解判断，倒不如用个计数器和做类似于高精度加法（每次只加一复杂都有保证）.然后对于10^9只能间隔打表了。 2.正方形计数【题目描述】给定平面上 N 个点，你需要计算以其中 4 个点为顶点的正方形的个数。注意这里的正方形边不一定 需要和坐标轴平行。 【输入格式】第一行一个数 N 以下 N 个点的坐标。 【输出格式】一个数，表示正方形的个数 【数据规模】对于 20%的数据，满足 1&lt;=N&lt;=20;对于 100%的数据，满足 1&lt;=N&lt;=500，-50&lt;=x[i],y[i]&lt;=50，点不会重叠。 【输入样例】7 0 0 0 1 1 0 1 1 1 2 2 1 2 2 Solution暴力枚举正方形的四个顶点判断边是否相等即可。或者枚举两个定点根据条件判断另外两个点是否存在。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct node&#123; int x,y; friend bool operator &lt; (node a,node b)&#123; if(a.x==b.x)return a.y&lt;b.y; return a.x&lt;b.x; &#125;&#125;point[550];int n,ans;int work(int x1,int y1,int x2,int y2)&#123; return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);&#125;int main()&#123; freopen(\"count.in\",\"r\",stdin); freopen(\"count.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;point[i].x,&amp;point[i].y); sort(point+1,point+1+n); for(int i=1;i&lt;=n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; int line_1=work(point[i].x,point[i].y,point[j].x,point[j].y); if(!line_1)continue; for(int k=j+1;k&lt;=n;k++) &#123; int line_2=work(point[i].x,point[i].y,point[k].x,point[k].y); if(line_1!=line_2)continue; for(int p=k+1;p&lt;=n;p++) &#123; int line_3=work(point[k].x,point[k].y,point[p].x,point[p].y); int line_4=work(point[p].x,point[p].y,point[j].x,point[j].y); int line_5=work(point[i].x,point[i].y,point[p].x,point[p].y); int line_6=work(point[j].x,point[j].y,point[k].x,point[k].y); if(line_2==line_3&amp;&amp;line_3==line_4&amp;&amp;line_5==line_6) ans++; &#125; &#125; &#125; &#125; printf(\"%d\",ans); return 0;&#125;/*70 00 11 01 11 22 12 2*/ 【输出样例】3 3.速算游戏【题目描述】jyx 和 cyy 打赌，比谁 24 点算得快，算得慢的那个人请客。24 点的规则是这样的：给定 4个 1..9 的整数，用括号改变运算顺序，通过加、减、乘、除通的一系列运算，得到整数 24，注意所有中间结果必须是整数（例如(22)/4 是允许的，而 2(2/4)是不允许的）。为了赢得这个比赛，请写一个程序帮助我作弊，快速地计算出 24 点。 【输入格式】一行 4 个整数，为给定的 4 个数字。输入数据保证有解。 【输出格式】一行，以字符串的形式输出结果，注意将每一步的运算的括号补齐（例如(3+5)+6 和3*(5+6)）如果有多种解答，输出字典顺序最小的一个。 【输入样例】2357 【输出样例】(((3*5)+2)+7) Solution被括号给骗了 感觉这道题挺蛮麻烦的，时只有3.5小时,所幸没有做，后来题时，真是傻逼题。太弱了…..括号在这题里只会有三种情况，自己想一想，然后依次写三个暴力就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF -2147483647using namespace std;int n[5],now[10],vis[10],r[50];int num[50][5];int cnt,tot;char ans[50][100];char trs(int x)&#123; if(x==1)return '+'; if(x==2)return '-'; if(x==3)return '*'; if(x==4)return '/';&#125;void Dfs_Pai(int pos)&#123; if(pos==5) &#123; cnt++; for(int i=1;i&lt;=4;i++) num[cnt][i]=now[i]; &#125; for(int i=1;i&lt;=4;i++) &#123; if(!vis[i]) &#123; now[pos]=n[i]; vis[i]=true; Dfs_Pai(pos+1); vis[i]=false; &#125; &#125;&#125;int calu(int a,int b,int opt)&#123; if(opt==1)return a+b; if(opt==2)return a-b; if(opt==3)return a*b; if(opt==4&amp;&amp;b!=0&amp;&amp;a%b==0)return a/b; return -INF;&#125;void Dfs_Judge(int p)&#123; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][1],num[p][2],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(result_1,num[p][3],j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(result_2,num[p][4],k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]='('; ans[tot][2]='('; ans[tot][3]=num[p][1]+'0'; ans[tot][4]=trs(i); ans[tot][5]=num[p][2]+'0'; ans[tot][6]=')'; ans[tot][7]=trs(j); ans[tot][8]=num[p][3]+'0'; ans[tot][9]=')'; ans[tot][10]=trs(k); ans[tot][11]=num[p][4]+'0'; ans[tot][12]=')'; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][1],num[p][2],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(num[p][3],num[p][4],j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(result_1,result_2,k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]='('; ans[tot][2]=num[p][1]+'0'; ans[tot][3]=trs(i); ans[tot][4]=num[p][2]+'0'; ans[tot][5]=')'; ans[tot][6]=trs(k); ans[tot][7]='('; ans[tot][8]=num[p][3]+'0'; ans[tot][9]=trs(j); ans[tot][10]=num[p][4]+'0'; ans[tot][11]=')'; ans[tot][12]=')'; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][3],num[p][4],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(num[p][2],result_1,j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(num[p][1],result_2,k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]=num[p][1]+'0'; ans[tot][2]=trs(k); ans[tot][3]='('; ans[tot][4]=num[p][2]+'0'; ans[tot][5]=trs(j); ans[tot][6]='('; ans[tot][7]=num[p][3]+'0'; ans[tot][8]=trs(i); ans[tot][9]=num[p][4]+'0'; ans[tot][10]=')'; ans[tot][11]=')'; ans[tot][12]=')'; &#125; &#125; &#125; &#125;&#125;bool cmp(int x,int y)&#123; for(int i=1;i&lt;=13;i++) &#123; if(ans[x][i]==ans[y][i])continue; return ans[x][i]&lt;ans[y][i]; &#125;&#125;int main()&#123; freopen(\"fun.in\",\"r\",stdin); freopen(\"fun.out\",\"w\",stdout); scanf(\"%d%d%d%d\",&amp;n[1],&amp;n[2],&amp;n[3],&amp;n[4]); Dfs_Pai(1); for(int i=1;i&lt;=cnt;i++) Dfs_Judge(i); for(int i=1;i&lt;=tot;i++) r[i]=i; sort(r+1,r+1+tot,cmp); printf(\"%s\",ans[r[1]]); return 0;&#125; /*2 3 5 7*/ 4.单人纸牌【题目描述】单人纸牌游戏，共 36 张牌分成 9 叠，每叠 4 张牌面向上。每次，游戏者可以从某两个不同的牌堆最顶上取出两张牌面相同的牌（如黑桃 10 和梅花 10）并且一起拿走。如果最后所有纸牌都被取走，则游戏者就赢了，否则游戏者就输了。George 很热衷于玩这个游戏，但是一旦有时有多种选择的方法，George 就不知道取哪一种好了，George 会从中随机地选择一种走，例如：顶上的 9 张牌为 KS,KH,KD,9H,8S,8D,7C,7D，6H，显然有 5 种取法： (KS,KH),(KS,KD),(KH,KD),(8S,8D),(7C,7D)，当然 George 取到每一种取法的概率都是 1/5。有一次，George 的朋友 Andrew 告诉他，这样做是很愚蠢的，不过 George 不相信，他认为如此玩最后成功的概率是非常大的。请写一个程序帮助 George 证明他的结论：计算按照他的策略，最后胜利的概率。 【输入格式】9 行每行 4 组用空格分开的字串，每个字串两个字符，分别表示牌面和花色，按照从堆底到堆顶的顺序给出。 【输出格式】一行，最后胜利的概率，精确到小数点后 6 位。 【输入样例】AS 9S 6C KS JC QH AC KH 7S QD JD KD QS TS JS 9H 6D TD AD 8S QC TH KC 8D 8C 9D TC 7C 9C 7H JH 7D8H 6S AH 6H 【输出样例】0.589314 Solution记忆化搜索轻松搞定，其实比较裸吧。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;char ch[10][5];bool f[5][5][5][5][5][5][5][5][5];double dp[5][5][5][5][5][5][5][5][5];double dfs(int c1,int c2,int c3,int c4,int c5,int c6,int c7,int c8,int c9)&#123; if(f[c1][c2][c3][c4][c5][c6][c7][c8][c9]) return dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]; f[c1][c2][c3][c4][c5][c6][c7][c8][c9]=true; int c[10]; c[1]=c1;c[2]=c2;c[3]=c3;c[4]=c4; c[5]=c5;c[6]=c6;c[7]=c7;c[8]=c8;c[9]=c9; int sum=0; for(int i=1;i&lt;=9;i++) for(int j=i+1;j&lt;=9;j++) &#123; if(ch[i][c[i]]==ch[j][c[j]]&amp;&amp;(c[i]&gt;0)&amp;&amp;(c[j]&gt;0)) &#123; sum++; c[i]--;c[j]--; dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]+=dfs(c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9]); c[i]++;c[j]++; &#125; &#125; if(sum!=0) dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]/=sum; return dp[c1][c2][c3][c4][c5][c6][c7][c8][c9];&#125;int main()&#123; freopen(\"double.in\",\"r\",stdin); freopen(\"double.out\",\"w\",stdout); for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=4;j++) &#123; char a,b; cin&gt;&gt;a&gt;&gt;b; ch[i][j]=a; &#125; f[0][0][0][0][0][0][0][0][0]=1; dp[0][0][0][0][0][0][0][0][0]=1; dp[4][4][4][4][4][4][4][4][4]=dfs(4,4,4,4,4,4,4,4,4); printf(\"%.6f\",dp[4][4][4][4][4][4][4][4][4]); return 0;&#125;/*AS 9S 6C KSJC QH AC KH7S QD JD KDQS TS JS 9H6D TD AD 8SQC TH KC 8D8C 9D TC 7C9C 7H JH 7D8H 6S AH 6H*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://dextertyw.github.io/tags/记忆化搜索/"}]},{"title":"noip模拟赛2017.7.20","slug":"[noip模拟赛2017.7.20]","date":"2017-07-20T07:01:57.632Z","updated":"2017-07-24T11:59:40.472Z","comments":true,"path":"2017/07/20/[noip模拟赛2017.7.20]/","link":"","permalink":"https://dextertyw.github.io/2017/07/20/[noip模拟赛2017.7.20]/","excerpt":"题目名称 产品排序 分球 地图 数页码 提交文件 sort.* ball.* map.* count.* 输入文件 sort.in ball.in map.in count.in 输出文件 sort.out ball.out map.out count.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 32MB 题目来源 vijos vijos 模拟题 模拟题","text":"题目名称 产品排序 分球 地图 数页码 提交文件 sort.* ball.* map.* count.* 输入文件 sort.in ball.in map.in count.in 输出文件 sort.out ball.out map.out count.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 32MB 题目来源 vijos vijos 模拟题 模拟题 产品排序题目描述有一系列产品，给定每个产品的加工时间和冷却成型时间（冷却过程产品之间没有关系，是单独 冷却的）。现在你手上有两台机器可以用来加工，你需要安排产品加工的顺序以及去哪台机器加工， 使得所有产品都成型的时间最早。机器之间互不相关，可以同时进行工作，一个机器一个时刻只能加 工一个产品。 输入格式第一行一个数 n，表示产品个数，以下 n 行，每行两个数分别表示产品的加工时间 A[i]和冷却时间 B[i]。 输出格式一个数，表示所有产品成型的最早时间。 数据规模对于 20%的数据，满足 n&lt;=6;对于 100%的数据，满足 n,A[i],B[i]&lt;=200。 输入样例3 14 33 41 输出样例6 题解对于一个机器的情况，我们贪心处理，按冷却时间降序排序一定是最优的(因为冷却时间长的肯定先加工嘛)然后考虑两个机器的情况，因为所有产品都是要加工的，所以两个机器加工的总时间一定，那么我们可以动规处理，dp[i][j]表示加工前i件产品，其中第一个机器加工时长为j的时候，最少什么时候加工完成，如此说来，状态转移方程就好写了如果用第一台机器加工，那么就是 如果用第二台机器加工，那么就是 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF (1&lt;&lt;30)using namespace std;int dp[202][40400];struct node&#123; int t1,t2;&#125;a[202];bool cmp(node x,node y)&#123; return x.t2&gt;y.t2;&#125;int sum[202];int main()&#123; freopen(\"sort.in\",\"r\",stdin); freopen(\"sort.out\",\"w\",stdout); int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i].t1,&amp;a[i].t2); sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]+a[i].t1; for(int ta=0;ta&lt;=sum[i];ta++)&#123; int tb=sum[i]-ta; dp[i][ta]=INF; if(ta&gt;=a[i].t1) dp[i][ta]=min(dp[i][ta],max(ta+a[i].t2,dp[i-1][ta-a[i].t1])); if(tb&gt;=a[i].t1) dp[i][ta]=min(dp[i][ta],max(tb+a[i].t2,dp[i-1][ta])); &#125; &#125; int ans=INF; for(int ta=0;ta&lt;=sum[n];ta++) ans=min(dp[n][ta],ans); printf(\"%d\",ans);&#125; 分球题目描述有 N 个标号的球分到 M 个无差别的盒子里，每个盒子至少有一个球，问方案数。 输入格式多组数据；每部分一行两个数 N、M。 输出格式每组数据输出一行，一个数，表示方案数。 数据规模对于 20%的数据，满足 1&lt;=N，M&lt;=10;对于 100%的数据，满足 1&lt;=N，M&lt;=100，数组组数&lt;=10。 输入样例42 11 输出样例7 1 样例解释N=4,M=21,234 ；2,134；3,124；4,123；12,34；13,24；14,23 题解高精度DP，待填坑 地图题目描述给定一张地图，定义 X 表示陆地，O 表示海洋。两个格子连通，当且仅当它们共边。一个大陆定 义是一个极大的陆地连通块。极大的连通块的定义是不存在一个格子与当前连通块中的某个格子相连 但不属于当前连通块。问地图中有几个大陆。 输入格式第一行两个数 N，M，表示地图的大小，以下 N 行，每行 M 个字母。 输出格式一个数，表示大陆个数。 数据规模对于 30%的数据，满足 1&lt;=N，M&lt;=50。对于 100%的数据，满足 1&lt;=N，M&lt;=1000。 输入样例5 5XXXOOOOXOOOOOXXXOOOOXOXXX 输出样例4 题解简单的搜索12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF (1&lt;&lt;30)#define LL long longusing namespace std;bool mp[2000][2000];int m,n,ans;char s[2000];int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;void dfs(int x,int y)&#123; mp[x][y]=true; for(int i=0;i&lt;4;i++)&#123; int xx=x+dx[i],yy=y+dy[i]; if(!mp[xx][yy]) dfs(xx,yy); &#125;&#125;int main()&#123; freopen(\"map.in\",\"r\",stdin); freopen(\"map.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",s+1); for(int j=1;j&lt;=m;j++) if(s[j]=='O') mp[i][j]=true; &#125; for(int i=1;i&lt;=n;i++) mp[i][0]=mp[i][m+1]=true; for(int j=1;j&lt;=m;j++) mp[0][j]=mp[n+1][j]=true; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(!mp[i][j])&#123; dfs(i,j); ans++; &#125; printf(\"%d\",ans);&#125;/*5 5XXXOOOOXOOOOOXXXOOOOXOXXX*/ 数页码题目描述一本书的页码是从 1-n 编号的连续整数：1，2，3…，n。请你求出全部页码中所有单个数字的 和，例如第 123 页，它的和就是 1+2+3=6。 输入格式一行为 n(1&lt;=n&lt;=10^9)。 输出格式一行，代表所有单个数字的和。 输入样例3456789 输出样例96342015 题解可以考虑分位处理，先统计个位上出现的，再算十位…以此类推。但是要注意不要忘了每个位置剩下的，因为由于每个位的数字不相同，所以可能…这个只能意会吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int c[10],n;long long ans;int Get_Num(int x)&#123; int rtn=0; while(x) &#123; x/=10; rtn++; &#125; return rtn;&#125;int main()&#123; freopen(\"count.in\",\"r\",stdin); freopen(\"count.out\",\"w\",stdout); scanf(\"%d\",&amp;n); int num=Get_Num(n); int pow=1; for(int j=1;j&lt;=num;j++) &#123; pow*=10; int Pre_Number=n/pow*pow; int Bac_Number=n-Pre_Number; for(int i=1;i&lt;=9;i++) c[i]+=Pre_Number/10; int Re_Number=Bac_Number*10/pow; for(int i=1;i&lt;Re_Number;i++) c[i]+=pow/10; c[Re_Number]+=Bac_Number-Re_Number*(pow/10)+1; &#125; for(int i=1;i&lt;=9;i++) ans+=c[i]*i; printf(\"%d\\n\",ans);&#125;/*31 43 34 1*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"dp","slug":"dp","permalink":"https://dextertyw.github.io/tags/dp/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"}]},{"title":"manacher练习题","slug":"回文检测","date":"2017-07-19T13:39:50.356Z","updated":"2017-07-24T12:01:05.870Z","comments":true,"path":"2017/07/19/回文检测/","link":"","permalink":"https://dextertyw.github.io/2017/07/19/回文检测/","excerpt":"回文检测做这道题的目的为了联系一下Manacher，也会专门再写一篇Manacher的专题题目描述据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母’A’-‘Z’和’a’-‘z’。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。","text":"回文检测做这道题的目的为了联系一下Manacher，也会专门再写一篇Manacher的专题题目描述据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母’A’-‘Z’和’a’-‘z’。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。 输入输出格式输入格式： 输入文件不会超过20,000字符。这个文件可能一行或多行，但是每行都不超过80个字符(不包括最后的换行符)。 输出格式： 输出的第一行应该包括找到的最长的回文的长度。下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。如果有多个回文长度都等于最大值，输出最前面出现的那一个。 输入输出样例输入样例#1：\\Confucius say: Madam, I’m Adam.\\输出样例#1：\\11Madam, I’m Adam 说明题目翻译来自NOCOW。\\USACO Training Section 1.3 题解这道题可能是Manacher的模板题吧，我总觉得马拉车这个名字很蠢….以前还真的是以为和马有关系，知道真相的我….. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;char ch[30010],c[50010];int p[50010],trs[50010],ans=-1,Left,Right,cnt,cht,tmp=-1;void check(int pos)&#123; if(p[pos]&gt;tmp) &#123; tmp=p[pos]; ans=p[pos]-1; Left=pos-p[pos]+1,Right=pos+p[pos]-1; if(c[Left]=='#')Left++,Right--; &#125;&#125;void Manacher()&#123; int MaxRight=0,pos=0; for(int i=1;i&lt;=cnt;i++)&#123; int j=2*pos-i; if(i&lt;MaxRight)&#123; p[i]=min(MaxRight-i+1,p[j]); check(i); &#125; else&#123; int ll=i,rr=i; while(ll-1&gt;=0&amp;&amp;rr+1&lt;=cnt+1) &#123; if(c[ll]==c[rr])&#123; ll--;rr++;p[i]++; &#125; else break; &#125; check(i); pos=i,MaxRight=p[i]+pos-1; &#125; &#125;&#125;int main()&#123;#ifdef YSW freopen(\"in.txt\",\"r\",stdin);#endif char cc; c[cnt]='$';c[++cnt]='#'; while((cc=getchar())!=EOF) &#123; ch[++cht]=cc; if(ch[cht]&gt;='a'&amp;&amp;ch[cht]&lt;='z') c[++cnt]=ch[cht],trs[cnt]=cht,c[++cnt]='#';; if(ch[cht]&gt;='A'&amp;&amp;ch[cht]&lt;='Z') c[++cnt]=ch[cht]-'A'+'a',trs[cnt]=cht,c[++cnt]='#'; &#125; Manacher(); int l=trs[Left],r=trs[Right]; printf(\"%d\\n\",ans); for(int i=l;i&lt;=r;i++) printf(\"%c\",ch[i]); return 0;&#125;","categories":[],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"https://dextertyw.github.io/tags/Manacher/"}]},{"title":"noip模拟赛2017.7.11","slug":"[noip模拟赛2017.7.11]","date":"2017-07-19T13:39:45.993Z","updated":"2017-07-24T12:19:42.770Z","comments":true,"path":"2017/07/19/[noip模拟赛2017.7.11]/","link":"","permalink":"https://dextertyw.github.io/2017/07/19/[noip模拟赛2017.7.11]/","excerpt":"模拟试题(三)【试题概览】 题目名称 中位数 敲砖块 单词 邮递员送信 提交文件 median.* brike.* words.* post.* 输入文件 median.in brike.in words.in post.in 输出文件 median.out brike.out words.out post.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB","text":"模拟试题(三)【试题概览】 题目名称 中位数 敲砖块 单词 邮递员送信 提交文件 median.* brike.* words.* post.* 输入文件 median.in brike.in words.in post.in 输出文件 median.out brike.out words.out post.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB 中位数【题目描述】有一个长度为 N 的数列{A1,A2,…,AN}，这 N 个数字恰好是 1..N 的一个排列。你需要统计有多少个 子序列{Ai,Ai+1,…,Aj}满足：i&lt;=j 且 j-i+1 为奇数，序列的中位数为 B。例如{5,1,3}的中位数为 3。 【输入格式】第一行包含两个正整数 N 和 B。第二行包含 N 个整数，第 i 个整数为 Ai. 【输出格式】仅包含一个整数，为满足条件的子序列的个数。 【数据规模】对于 30%的数据，满足 N&lt;=100;对于 60%的数据，满足 N&lt;=1000;对于 100%的数据，满足 N&lt;=100000,1&lt;=B&lt;=N。 【输入样例】7 4 5 7 2 4 3 1 6 【输出样例】4 题解第一题想了一个比n^2小那么一点的方法，奈何忘记判断边界，直接gg（md还有20分）。8020.！&amp;￥#！正解直接用d[i]前缀和的形式统计i位置及以前比B大的数和比它小的数个数之差，然后如果在B位置后面存在一个位置j使d[j]==d[i],则说明在i~j这段区间中比B大的数与比B小的数相等，和一个合法区间。然后如何O(n)判断？就是桶排序的类似思想，打标记。1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,b,a[100010],gre[100010],les[100010],num[100010],flag[200010];int trs(int x)&#123;return x+100010;&#125;int main()&#123; freopen(&quot;median.in&quot;,&quot;r&quot;,stdin); freopen(&quot;median.out&quot;,&quot;w&quot;,stdout); int pos,ans=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;b); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; gre[i]=gre[i-1],les[i]=les[i-1]; if(a[i]&gt;b)gre[i]++; if(a[i]&lt;b)les[i]++; if(a[i]==b)pos=i; num[i]=gre[i]-les[i]; &#125; for(int i=0;i&lt;=pos;i++)flag[trs(num[i])]++; for(int i=pos;i&lt;=n;i++)ans+=flag[trs(num[i])]; cout&lt;&lt;ans; return 0;&#125;/*7 47 2 4 3 6 5 1*/ 敲砖块【题目描述】在一个凹槽中放置了 N 层砖块，最上面的一层有 N 块砖，从上到下每层依次减少一块砖。每块砖 都有一个分值，敲掉这块砖就能得到相应的分值，如图所示14 15 4 3 2333 33 76 22 13 1222 2331如果你想敲掉第 i 层的第 j 块砖的话，若 i=1，你可以直接敲掉它；若 i&gt;1，则你必须先敲掉第 i-1 层的第 j 和第 j+1 块砖。你现在可以敲掉最多 M 块砖，求得分最多能有多少。 【输入格式】第一行有两个正整数 N 和 M；接下来的 N 行，描述这 N 层砖块上的分值 A[i,j]，满足 0&lt;=A[i,j]&lt;=100。 【输出格式】仅一行，包含一个整数，为最大的得分。 【数据规模】对于 20%的数据，满足 1&lt;=N&lt;=10,1&lt;=M&lt;=30;对于 100%的数据，满足 1&lt;=N&lt;=50,1&lt;=M&lt;=500。 【输入样例】4 5 2 2 3 4 8 2 7 2 3 49 【输出样例】19 题解（xjb算法）幸亏今天的第二题苟住了，dp直接AC，但我想说一下cxy想的记忆化搜索（1.因为dp真的很烦，公式推错直接gg.2.记忆化搜索还比较好想）。我们每次只处理一列中的选择方案，假设敲i及其以上（其实i以上是必然会被敲）由于敲砖方式的限制，下一列的搜索是存在限制的，必须敲掉i-1块及以上，当然也可以敲下面的。既然这个清楚了就比较好完成代码了。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define N 51using namespace std;int n,m,flag[N][N][(N*(N+1)/2)],dp[N][N][(N*(N+1)/2)],mp[N][N],sum[N][N];int dfs(int lie,int p,int lft)&#123; int rtn=sum[lie][p]; if(flag[lie][p][lft])return dp[lie][p][lft]; flag[lie][p][lft]=1; if(2*lft&lt;(p*(p+1)))return dp[lie][p][lft]=-1; if(lft&lt;0)return dp[lie][p][lft]=-1; if(lie&gt;n)return dp[lie][p][lft]=0; if(lft==0)return dp[lie][p][lft]=0; for(int i=p;i&lt;=n-lie+1;i++) &#123; int now=sum[lie][i]; int k=dfs(lie+1,max(i-1,0),lft-i); if(k==-1)break; rtn=max(now+k,rtn); &#125; return dp[lie][p][lft]=rtn; &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n-i+1;j++) scanf(&quot;%d&quot;,&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) sum[i][j]=sum[i][j-1]+mp[j][i]; printf(&quot;%d&quot;,dfs(1,0,m)); return 0;&#125; 单词【题目描述】有 N 个单词和字符串 T，按字典顺序输出以字符串 T 为前缀的所有单词。 【输入格式】第一行包含一个正整数 N；接下来 N 行，每行一个单词，长度不超过 50；最后一行包含字符串 T。 【输出格式】按字典顺序升序输出答案。 【数据规模】对于 60%的数据，满足 1&lt;=N&lt;=1000;对于 100%的数据，满足 1&lt;=N&lt;=10000 且所有字符均为小写字母。 【输入样例】6 na no ki ki ka ku k 【输出样例】ka ki ki ku 题解 很烦，string果然还是不能被接受。不过今天通过这道题也学到了，如果我们不便对于一个二维数组进行排序，我们可以间接通过对其下标的排序来完成。不过这道题的小技巧在于我们可以把要匹配的前缀也加入排列，然后再加入一个前缀后+’z’+1的一个串来保证会被派到最后一个，通过一开始的下标记录，我们可以完成对排序后的数组经行O(n)查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,cnt,l[10010],bh[10010];char ch[10010][100]; bool cmp(int x,int y)&#123; int len=min(l[x],l[y]); for(int i=0;i&lt;=len-1;i++) &#123; if(ch[x][i]==ch[y][i])continue; return ch[x][i]&lt;ch[y][i]; &#125; return l[x]&lt;l[y];&#125;int main()&#123; freopen(&quot;words.in&quot;,&quot;r&quot;,stdin); freopen(&quot;words.out&quot;,&quot;w&quot;,stdout); int pos; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,ch[i]),l[i]=strlen(ch[i]),bh[i]=i; scanf(&quot;%s&quot;,ch[0]); l[0]=strlen(ch[0]),bh[0]=0; for(int i=0;i&lt;l[0];i++) ch[n+1][i]=ch[0][i]; ch[n+1][l[0]]=&apos;z&apos;+1,l[n+1]=l[0]+1,bh[n+1]=n+1; stable_sort(bh,bh+2+n,cmp); for(int i=0;i&lt;=n+1;i++)if(bh[i]==0)&#123;pos=i;break;&#125; for(int i=pos+1;i;i++)&#123; if(bh[i]==n+1)break; else printf(&quot;%s\\n&quot;,ch[bh[i]]); &#125; return 0;&#125;/*6nanokikikakuk*/ 邮递员送信【题目描述】有一个邮递员要送东西，邮局在结点 1。他总共要送 N-1 样东西，其目的地分别是 2-N。由于这个 城市的交通比较繁忙，因此所有的道路都是单行的，共有 M 条道路，通过每条道路需要一定的时间。 这个邮递员每次只能带一样东西。求送完这 N-1 样东西并且最终回到邮局最少需要多少时间。 【输入格式】第一行包含一个正整数 N 和 M；接下来有 M 行，每行三个正整数 U、V、W，表示该条道路为从 U 到 V 的，且通过这条道路需要 W 的时间。满足 1&lt;=U,V&lt;=N,1&lt;=W&lt;=100000，输入保证任意两点都能互相到达。 【输出格式】包含一个整数，为最少需要的时间 【数据规模】30%的数据，1&lt;=N&lt;=200;100%的数据，1&lt;=N&lt;=1000，1&lt;=M&lt;=10000. 【输入样例】注意：如果有这样的情况：（1109） （1102） （1101）以最小的 w=1 进行存储 5 10 2 3 5 1 5 5 3 5 6 1 2 8 1 3 8 5 3 4 4 1 8 4 5 3 3 5 6 5 4 2 【输出样例】83 题解题目真的很有病，明明说了边数不超过10000，结果来个80000的数据，也是没谁了。由于题目中的边是单向边，所以建个反向边跑一跑就完事了，代码写的丑是真的，后来改题的时候弄了半天，傻X出题人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long longusing namespace std;int n,m,cnt,p[1010],edge[1010][1010],vis[1010];LL dis[1010];struct node&#123; int a,b,w,nt;&#125;e[10010],t[10010];void add1(int x,int y,int w)&#123; cnt++; e[cnt].a=x,e[cnt].b=y,e[cnt].w=w; e[cnt].nt=p[x],p[x]=cnt;&#125;void add2(int x,int y,int w)&#123; cnt++; t[cnt].a=x,t[cnt].b=y,t[cnt].w=w; t[cnt].nt=p[x],p[x]=cnt;&#125;queue&lt;int&gt;q1,q2;void spfa1()&#123; for(int i=1;i&lt;=n;i++)dis[i]=1e15;dis[1]=0; q1.push(1);vis[1]=1; while(!q1.empty())&#123; int k=q1.front();q1.pop();vis[k]=0; for(int i=p[k];i;i=e[i].nt)&#123; int kk=e[i].b; if(dis[kk]&gt;dis[k]+e[i].w)&#123; dis[kk]=dis[k]+e[i].w; if(!vis[kk])&#123; vis[kk]=1; q1.push(kk); &#125; &#125; &#125; &#125;&#125;void spfa2()&#123; for(int i=1;i&lt;=n;i++)dis[i]=1e15;dis[1]=0; q2.push(1);vis[1]=1; while(!q2.empty())&#123; int k=q2.front();q2.pop();vis[k]=0; for(int i=p[k];i;i=t[i].nt)&#123; int kk=t[i].b; if(dis[kk]&gt;dis[k]+t[i].w)&#123; dis[kk]=dis[k]+t[i].w; if(!vis[kk])&#123; vis[kk]=1; q2.push(kk); &#125; &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;post.in&quot;,&quot;r&quot;,stdin); freopen(&quot;post.out&quot;,&quot;w&quot;,stdout); LL ans=0; memset(edge,63,sizeof(edge)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); edge[x][y]=min(edge[x][y],z); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(edge[i][j]&lt;=100000&amp;&amp;i!=j) add1(i,j,edge[i][j]); spfa1(); for(int i=2;i&lt;=n;i++) ans+=dis[i]; memset(p,0,sizeof(p)),cnt=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(edge[i][j]&lt;=100000&amp;&amp;i!=j) add2(j,i,edge[i][j]); spfa2(); for(int i=2;i&lt;=n;i++) ans+=dis[i]; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;/*5 102 3 51 5 53 5 61 2 81 3 85 3 44 1 84 5 33 5 6 5 4 2*/*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"dp","slug":"dp","permalink":"https://dextertyw.github.io/tags/dp/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"}]}]}