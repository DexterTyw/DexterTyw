{"meta":{"title":"Tyw_ei","subtitle":"For Our Future","description":"Gal Gadot","author":"by Dexter Yue","url":"https://dextertyw.github.io"},"pages":[{"title":"About","date":"2017-07-24T11:34:27.000Z","updated":"2017-07-26T07:29:59.040Z","comments":true,"path":"About/index.html","permalink":"https://dextertyw.github.io/About/index.html","excerpt":"","text":"关于博主：基本1.一名学OI的菜鸟，由于不想学综合，在竞赛班苟着… 2.没有什么比较高远的目标，还是继续苟着 3.然后最重要的，不是二次元QAQ，Orz，挺喜欢Gal Gadot 4.处于幼年时期，如果有大佬不幸路过，别d.Orz 日常1.被同组的XXX各种花式吊打，心服口服 2.求同组的XXX带躺，QAQ 3.看Gal Gadot的ins，twitter…(颓废) 4.coc（垃圾7本） 一切都是为了将来，加油！"},{"title":"Links","date":"2017-07-26T07:35:00.745Z","updated":"2017-07-26T07:35:00.745Z","comments":true,"path":"link/index.html","permalink":"https://dextertyw.github.io/link/index.html","excerpt":"","text":"AnoxiacxyxljHeret1chamsterwk"}],"posts":[{"title":"CDQ学习笔记","slug":"CDQ分治学习笔记","date":"2017-07-25T14:19:51.909Z","updated":"2017-07-25T14:53:32.017Z","comments":true,"path":"2017/07/25/CDQ分治学习笔记/","link":"","permalink":"https://dextertyw.github.io/2017/07/25/CDQ分治学习笔记/","excerpt":"CDQ 分治学习笔记学习的目的在任何一个OIer的职业生涯中，都会碰到一些繁琐的数据结构题，而现在的省选有基本是数据结构大战，可见数据结构的重要性，但是和我说的CDQ有什么关系QAQ？？？数据结构写起来，基本上就呵呵了，动不动两三百行的代码，调试时基本万念俱灰。。。（可能是我比较菜QAQ）这个时候CDQ的用处就很明显的，写起来简单，写起来简单，写起来简单！！！","text":"CDQ 分治学习笔记学习的目的在任何一个OIer的职业生涯中，都会碰到一些繁琐的数据结构题，而现在的省选有基本是数据结构大战，可见数据结构的重要性，但是和我说的CDQ有什么关系QAQ？？？数据结构写起来，基本上就呵呵了，动不动两三百行的代码，调试时基本万念俱灰。。。（可能是我比较菜QAQ）这个时候CDQ的用处就很明显的，写起来简单，写起来简单，写起来简单！！！ 算法要求与使用大前提:CDQ一定是处理离线算法，如果强制在线，还是要么暴力，要么刚数据结构。 使用：1.区间维护什么的就乱搞了，其实也用不到CDQ，但我们要清楚，区间维护其实就是维护一个二维偏序，具体做法我们稍后再说。2.CDQ的真正用处在于维护一个三维偏序，一般的做法是套用一个树状数组维护第三维。三维偏序的理解，举个例子给你很多三维坐标如(a,b,c),希望你求坐标满足:a&lt;x&amp;&amp;b&lt;y&amp;&amp;c&lt;z的点的个数有多少个； 具体实现很多前辈都说CDQ的写法与归并排序超级像，其实也真的是超级像。先说一下二维的实现：如果给你一个区间，有很多点权值，支持单点修改和区间查询。其实树状数组乱秒，考虑CDQ怎么做。对于每个操作我们必须要维护一个时间序，否则会乱套。那么考虑这么一个事实，每次修改操作一定是对后面发生的询问有影响，而我们已经将操作们按照时间排了序，分治的模型可能就出来了吧QAQ。我们递归枚举左区间和右区间，只是在合并前要多一步，考虑左区间中元素对右区间的影响：记操作的区间的左端点是x，右端点是y;那么满足 q[i].x&lt;q[j].x都会对查询有影响，注意我们查询的是两个前缀和：sum[x-1],sum[y];那么我们很清楚查询到x-1时，对这次区间询问的答案应该是减去sum[x-1]的，而到y时，便是加上sum[y]。好了可以总结一下，CDQ的基本思路就是保证左区间与右区间的修改和查询独立协调后，处理左区间对右区间的影响。如果左区间的所有元素都不满足于修改条件（见上），那么说明右区间的查询部分是不受限制的，可以直接更新答案。好了差不多就这样了，如果还是不清楚的话，可以在看几篇博客，知识点不可能看一篇文章就能学会的。 三维偏序三维偏序其实是对二位偏序的拓展。我们可以保证默认序时间序是有序的，我们也能保证第二维在维护的时候可以有序，但是第三维我们只能放弃，否则会冲突。这时候我们可以借助一个简单的数据结构，比如说树状数组来维护。 先放一道入门题比模板题多一点点操作在于只用容斥把查询稍微转化一下就行了因为有些查询是对答案有利，有些不是，所以定义的时候可以应入一个w变量=1||-1来记录状态。贴一波同组写的题解 传送门123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define lowbit(x) (x&amp;(-x))using namespace std;int s,w,sz[2000100];struct node&#123; int type,x,y,num,w; node(int _type=0,int _x=0,int _y=0,int _num=0,int _w=0)&#123; type=_type,x=_x,y=_y,num=_num,w=_w; &#125; friend bool operator &lt;= (node a,node b)&#123; return a.x&lt;=b.x; &#125;&#125;q[500500],tmp[2000100];int cnt,tot,ans[100010];void update(int x,int y)&#123; for(int i=x;i&lt;=w;i+=lowbit(i)) sz[i]+=y;&#125;int query(int x)&#123; int rtn=0; for(int i=x;i;i-=lowbit(i)) rtn+=sz[i]; return rtn;&#125;void CDQ(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; CDQ(l,mid),CDQ(mid+1,r); int i=l,j=mid+1,o=0; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; if(q[i]&lt;=q[j]) &#123; if(q[i].type==1) update(q[i].y,q[i].w); tmp[o++]=q[i++]; &#125; else &#123; if(q[j].type==2) ans[q[j].num]+=query(q[j].y)*q[j].w; tmp[o++]=q[j++]; &#125; &#125; while(i&lt;=mid) &#123; if(q[i].type==1)update(q[i].y,q[i].w); tmp[o++]=q[i++]; &#125; while(j&lt;=r) &#123; if(q[j].type==2)ans[q[j].num]+=query(q[j].y)*q[j].w; tmp[o++]=q[j++]; &#125; for(int i=l;i&lt;=mid;i++) if(q[i].type==1)update(q[i].y,-q[i].w); for(int i=0;i&lt;o;i++) q[i+l]=tmp[i];&#125;int main()&#123; scanf(\"%d%d\",&amp;s,&amp;w); while(true) &#123; int x,y,x1,y1,w; int opt;scanf(\"%d\",&amp;opt); if(opt==3)break; if(opt==1)&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w); q[++cnt]=node(1,x,y,0,w); &#125; if(opt==2)&#123; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;x1,&amp;y1); q[++cnt]=node(2,x-1,y-1,++tot,1); q[++cnt]=node(2,x1,y1,tot,1); q[++cnt]=node(2,x-1,y1,tot,-1); q[++cnt]=node(2,x1,y-1,tot,-1); ans[tot]+=s*(x1-x+1)*(y1-y+1); &#125; &#125; CDQ(1,cnt); for(int i=1;i&lt;=tot;i++)printf(\"%d\\n\",ans[i]); return 0;&#125; /*0 21 1 1 12 1 1 1 13 */","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://dextertyw.github.io/tags/学习笔记/"},{"name":"CDQ","slug":"CDQ","permalink":"https://dextertyw.github.io/tags/CDQ/"}]},{"title":"noip模拟赛2017.7.25","slug":"[noip模拟赛2017.7.25]","date":"2017-07-25T06:42:14.823Z","updated":"2017-07-25T07:21:29.999Z","comments":true,"path":"2017/07/25/[noip模拟赛2017.7.25]/","link":"","permalink":"https://dextertyw.github.io/2017/07/25/[noip模拟赛2017.7.25]/","excerpt":"Thinking Bear #1——NOIP 2014 提高组模拟赛竞赛时间：2014 年 8 月 17 日 18:30－22:00 中文题目名称 拆地毯 还教室 皇后游戏 英文题目名称 carpet classroom game 每个测试点时限 1 秒 1 秒 1 秒 内存限制 512MB 512MB 512MB 测试点数目 10 20 20 每个测试点分值 10 5 5 是否有部分分 否 否 否 题目类型 传统型 传统型 传统型","text":"Thinking Bear #1——NOIP 2014 提高组模拟赛竞赛时间：2014 年 8 月 17 日 18:30－22:00 中文题目名称 拆地毯 还教室 皇后游戏 英文题目名称 carpet classroom game 每个测试点时限 1 秒 1 秒 1 秒 内存限制 512MB 512MB 512MB 测试点数目 10 20 20 每个测试点分值 10 5 5 是否有部分分 否 否 否 题目类型 传统型 传统型 传统型 注意：最终测试时，将开启-O2 优化开关。Thinking Bear #1 拆地毯【引子】还记得 NOIP 2011 提高组 Day1 中的铺地毯吗？时光飞逝，光阴荏苒，三年 过去了。组织者精心准备的颁奖典礼早已结束，留下的则是被人们踩过的地毯。 请你来解决类似于铺地毯的另一个问题。 【问题描述】会场上有 n 个关键区域，不同的关键区域由 m 条无向地毯彼此连接。每条 地毯可由三个整数 u、v、w 表示，其中 u 和 v 为地毯连接的两个关键区域编号， w 为这条地毯的美丽度。 由于颁奖典礼已经结束，铺过的地毯不得不拆除。为 了贯彻勤俭节约的原则， 组织者被要求只能保留 K 条地毯，且保留的地毯构成的图中，任意可互相到达 的两点间只能有一种方式互相到达。换言之，组织者要求新图中不能有环。现在 组织者求助你，想请你帮忙算出这 K 条地毯的美丽度之和最大为多少。 【输入格式】第一行包含三个正整数 n、m、K。 接下来 m 行中每行包含三个正整数 u、v、w。 【输出格式】只包含一个正整数，表示这 K 条地毯的美丽度之和的最大值。 【样例输入】5 4 31 2 101 3 92 3 74 5 3 【样例输出】22 【样例说明】选择第 1、2、4 条地毯，美丽度之和为 10 + 9 + 3 = 22。 若选择第 1、2、3 条地毯，虽然美丽度之和可以达到 10 + 9 + 7 = 26，但这 将导致关键区域 1、2、3 构成一个环，这是题目中不允许的。Thinking Bear #1 拆地毯第 3 页 共 8 页 【数据规模与约定】所有测试点的数据规模如下：保证至 少存在一种方案使得在原图中可以选出K条边，这K条边构成的新图环。 Solution很裸的最大生成树保证选满k条边就不用担心了….1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n,m,k,fa[100100];struct node&#123; int a,b,w;&#125;e[100100];bool cmp(node a,node b)&#123; return a.w&gt;b.w;&#125;int findf(int x)&#123; if(fa[x]==x)return x; else return fa[x]=findf(fa[x]);&#125;int main()&#123; freopen(\"carpet.in\",\"r\",stdin); freopen(\"carpet.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(register int i=1;i&lt;=n;i++)&#123;fa[i]=i;&#125; for(register int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].a,&amp;e[i].b,&amp;e[i].w); sort(e+1,e+1+m,cmp); int cc=1,ans=0; while(k) &#123; int from=e[cc].a,to=e[cc].b,w=e[cc].w; int fa_from=findf(from); int fa_to=findf(to); if(fa_from!=fa_to) &#123; ans+=w; fa[fa_from]=fa_to; k--; &#125; cc++; &#125; printf(\"%d\",ans); return 0;&#125; /*5 4 31 2 10 1 3 9 2 3 7 4 5 3 */ Thinking Bear #1 还教室【引子】还记得 NOIP 2012 提高组 Day2 中的借教室吗？时光飞逝，光阴荏苒，两年 过去了，曾经借教室的同学们纷纷归还自己当初租借的教室。请你来解决类似于 借教室的另一个问题。 【问题描述】在接受借教室请求的 n 天中，第 i 天剩余的教室为 ai个。作为大学借教室服 务的负责人，你需要完成如下三种操作共 m 次： ① 第 l 天到第 r 天，每天被归还 d 个教室。 ② 询问第 l 天到第 r 天教室个数的平均数。 ③ 询问第 l 天到第 r 天教室个数的方差。 【输入格式】第一行包括两个正整数 n 和 m，其中 n 为借教室的天数，m 为操作次数。 接下来一行，共 包含 n 个整数，第 i 个整数表示第 i 天剩余教室数目为 ai个。 接下来 m 行，每行的第一个整数为操作编号（只能为 1 或 2 或 3），接下来 包含两个正整数 l 和 r，若操作编号为 1，则接下来再包含一个正整数 d。 【输出格式】对于每个操作 2 和操作 3，输出一个既约分数（分子与分母互质）表示询问 的答案（详见样例）。 若 答 案 为 0 ， 请 输出“0/1”（不含引号）。【样例输入】5 4 1 2 3 4 5 1 1 2 3 2 2 4 3 2 4 3 1 5 【样例输出】4/1 2/3 14/25Thinking Bear #1 还教室第 5 页 共 8 页 【样例说明】 【数学小贴士】 【数据规模与约定】所有测试点的数据规模如下： 对于全部测试数据满足：1 ≤ l ≤ r ≤ n，0 ≤ ai ≤ 10，1 ≤ d ≤ 3，操作 1 的数量 不超过 10%。注意：ai和 d 的范围很小及操作 1 数量很少的原因是为了保证答案 的分子不会很大，以防止答案的分子溢出 64 位整数的范围，这与题目做法无关。 Solution很裸的线段树，这些题的题面都很迷，贼尴尬的背景，既然是分数输出，那么我们肯定不是直接对答案进行维护，第一问好说仅维护一个区间和，而第二问我们可以推推公式：d代表的是区间加值，代表的是区间长度而观察到我们已经维护了区间的求和，那么再维护一个平方和就可以了QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define LL long longusing namespace std;int n,q;struct node&#123; int l,r; LL s1,s2,d;&#125;T[400100];inline int read()&#123; char c=getchar();int rtn=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;rtn=rtn*10+c-'0';c=getchar();&#125; return rtn*f;&#125;void Build_Tree(int p,int l,int r)&#123; T[p].l=l,T[p].r=r; if(l==r)return; int mid=(l+r)&gt;&gt;1; Build_Tree(p&lt;&lt;1,l,mid); Build_Tree(p&lt;&lt;1|1,mid+1,r);&#125;inline void deal(int p,int c)&#123; int ll=T[p].l,rr=T[p].r; T[p].d+=c; T[p].s2=T[p].s2+(rr-ll+1)*c*c+2*c*T[p].s1; T[p].s1=T[p].s1+(rr-ll+1)*c;&#125;inline void pushdown(int p)&#123; int ls=p&lt;&lt;1,rs=p&lt;&lt;1|1; deal(ls,T[p].d);deal(rs,T[p].d); T[p].d=0;&#125;inline void pushup(int p)&#123; T[p].s1=T[p&lt;&lt;1].s1+T[p&lt;&lt;1|1].s1; T[p].s2=T[p&lt;&lt;1].s2+T[p&lt;&lt;1|1].s2;&#125;void update(int p,int l,int r,int c)&#123; int ll=T[p].l,rr=T[p].r; if(ll==l&amp;&amp;rr==r) &#123; deal(p,c); return; &#125; pushdown(p); int mid=(ll+rr)&gt;&gt;1; if(r&lt;=mid)update(p&lt;&lt;1,l,r,c); else if(l&gt;mid)update(p&lt;&lt;1|1,l,r,c); else&#123; update(p&lt;&lt;1,l,mid,c); update(p&lt;&lt;1|1,mid+1,r,c); &#125; pushup(p);&#125;LL query_aven(int p,int l,int r)&#123; int ll=T[p].l,rr=T[p].r; if(ll==l&amp;&amp;rr==r)return T[p].s1; pushdown(p); int mid=(ll+rr)&gt;&gt;1; if(r&lt;=mid)return query_aven(p&lt;&lt;1,l,r); else if(l&gt;mid)return query_aven(p&lt;&lt;1|1,l,r); else&#123; return query_aven(p&lt;&lt;1,l,mid)+ query_aven(p&lt;&lt;1|1,mid+1,r); &#125;&#125;LL query_cha(int p,int l,int r)&#123; int ll=T[p].l,rr=T[p].r; if(ll==l&amp;&amp;rr==r)return T[p].s2; pushdown(p); int mid=(ll+rr)&gt;&gt;1; if(r&lt;=mid)return query_cha(p&lt;&lt;1,l,r); else if(l&gt;mid)return query_cha(p&lt;&lt;1|1,l,r); else&#123; return query_cha(p&lt;&lt;1,l,mid)+ query_cha(p&lt;&lt;1|1,mid+1,r); &#125;&#125;LL gcd(LL a,LL b)&#123; if(b==0)return a; else return gcd(b,a%b);&#125;void print(LL x,LL y)&#123; LL gcd_div=gcd(x,y); LL o1=x/gcd_div,o2=y/gcd_div; printf(\"%lld/%lld\\n\",o1,o2);&#125;int main()&#123; freopen(\"classroom.in\",\"r\",stdin); freopen(\"classroom.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;q); Build_Tree(1,1,n); for(register int i=1;i&lt;=n;i++)&#123;int x=read();update(1,i,i,x);&#125; while(q--) &#123; int opt=read(),from=read(),to=read(); if(opt==1) &#123; int cc=read(); update(1,from,to,cc); continue; &#125; if(opt==2) &#123; LL ans=query_aven(1,from,to),len=to-from+1; print(ans,len); continue; &#125; if(opt==3) &#123; LL ans=query_cha(1,from,to); LL x_=query_aven(1,from,to); LL len=to-from+1; print(len*ans-x_*x_,len*len); continue; &#125; &#125; return 0;&#125;/*5 4 1 2 3 4 5 1 1 2 3 2 2 4 3 2 4 3 1 5*/ Thinking Bear #1 皇后游戏【引子】还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年 过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游 戏的另一个问题。 【问题描述】皇后有 n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆 节来临，皇后决定为 n 位大臣颁发奖金，其中第 i 位大臣所获得的奖金数目为第 i－1 位大臣所获得奖金数目与前 i 位大臣左手上的数的和的较大值再加上第 i 位 大臣右手上的数。 形式化地讲：我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi， 则第 i 位大臣获得的奖金数目为 ci可以表达为：当然,吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安 排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。 注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一 位大臣的位置。 【输入格式】第一行包含一个正整数 T，表示测试数据的组数。 接下来 T 个部分，每个部分的第一行包含一个正整数 n，表示大臣的数目。 每个部分接下来 n 行中，每 行 两个正整数，分 别 为 a i 和 b i ，含 义 如 上文所述。 【输出格式】共 T 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 【样例输入 1】1 3 4 1 2 2 1 2Thinking Bear #1 皇后游戏第 7 页 共 8 页 【样例输出 1】8 【样例说明 1】按照 1、2、3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 10；按照 1、3、2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9；按照 2、1、3 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9；按照 2、3、1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8；按照 3、1、2 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 9；按照 3、2、1 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 8。当按照 3、2、1 这样排列队伍时，三位大臣左右手的数分别为： (1, 2)、(2, 2)、(4, 1) 第 1 位大臣获得的奖金为 1 + 2 = 3； 第 2 位大臣获得的奖金为 max{3, 3} + 2 = 5； 第 3 为大臣获得的奖金为 max{5, 7} + 1 = 8。 【样例输入 2】2 5 85 100 95 99 76 87 60 97 79 85 12 9 68 18 45 52 61 39 83 63 67 45 99 52 54 82 100 23 54 99 94 63 100 52 68 【样例输出 2】528 902Thinking Bear #1 皇后游戏第 8 页 共 8 页 【数据规模与约定】所有测试点的数据规模如下：对于全部测试数据满足：1 ≤ ai, bi ≤ 109。 【特别提示】由于评测在 Linux 下进行，请 C++选手务必注意 Linux 系统下 rand()函数返 回值的取值范围是[0, 231). Solution这个和国王的游戏比起来可能没有高精度，但是公式个人感觉是要麻烦一些，考场上没有做出来….qwq。大概就是很普通的贪心，观察到后一个人拿的钱是在钱一个人拿的钱的基础上有所增加，我们如果能保证后面的人拿钱最少那么答案就越小，根据公式贪心，假设前i-2个人都排好队，现在要排第i-1和第i个人：（注意c的下标意义是和a，b的下标意义不一样）1.考虑第i-1个人放在前面：2.考虑第i个人放在前面：我们排序的时候只用比较那种的ci更小就可以了两个公式有公共部分，化简得到：1.2.这就是排序的标准！！当然要是想骗分的话还是比较简单的，可以选择多重排序结构，选一个最小答案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;inline int read()&#123; char c=getchar();int rtn=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;rtn=rtn*10+c-'0';c=getchar();&#125; return rtn*f;&#125;LL c,sum;struct node&#123; LL l,r;&#125;p[505000];bool cmp(node a,node b)&#123; return max(a.l+a.r+b.r,a.l+b.l+b.r)&lt;max(b.l+b.r+a.r,b.l+a.l+a.r);&#125;int main()&#123; //freopen(\"game.in\",\"r\",stdin); //freopen(\"game.out\",\"w\",stdout); int T;T=read(); while(T--) &#123; c=0,sum=0; int n;n=read(); for(register int i=1;i&lt;=n;i++)p[i].l=read(),p[i].r=read(); sort(p+1,p+1+n,cmp); c=p[1].l+p[1].r;sum+=p[1].l; for(register int i=2;i&lt;=n;i++) &#123; sum+=p[i].l; c=max(c,sum)+p[i].r; &#125; printf(\"%lld\\n\",c); &#125; return 0;&#125;/*1 3 4 1 2 2 1 2 2 5 85 100 95 99 76 87 60 97 79 85 12 9 68 18 45 52 61 39 83 63 67 45 99 52 54 82 10023 54 99 9463 100 52 68*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"线段树","slug":"线段树","permalink":"https://dextertyw.github.io/tags/线段树/"},{"name":"贪心","slug":"贪心","permalink":"https://dextertyw.github.io/tags/贪心/"}]},{"title":"二维树状数组入门题","slug":"Matrix","date":"2017-07-24T11:57:35.434Z","updated":"2017-07-24T12:06:18.418Z","comments":true,"path":"2017/07/24/Matrix/","link":"","permalink":"https://dextertyw.github.io/2017/07/24/Matrix/","excerpt":"Matrix (poj 2155)传送门Time Limit: 3000MSMemory Limit: 65536KDescriptionGiven an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2). Q x y (1 &lt;= x, y &lt;= n) querys A[x, y].","text":"Matrix (poj 2155)传送门Time Limit: 3000MSMemory Limit: 65536KDescriptionGiven an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2). Q x y (1 &lt;= x, y &lt;= n) querys A[x, y]. InputThe first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case. The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above.OutputFor each querying output one line, which has an integer representing A[x, y]. There is a blank line between every two continuous test cases.Sample Input12 10C 2 1 2 2Q 2 2C 2 1 2 1Q 1 1C 1 1 2 1C 1 2 1 2C 1 1 2 2Q 1 1C 1 1 2 1Q 2 1 Sample Output1001SourcePOJ Monthly,Lou Tiancheng 题意对于一个0,1矩阵，支持左下(x1,y1)-右上(x2,y2)矩形区域内的反转，然后对单点(x,y)的查询。 Solution今天才学的二维树状数组（菜的一匹），其实看到对于一个二维区域的维护应该就能想到这类型的数据结构。那么对于单点查询，结合树状数组可想到是由差分来实现的，因为树状数组只能提取前缀和。然后对于一个二维平面如何加值，类似于一维中的s[x]+v,s[y]-v。推广到二维则有： 可以看一下这个图。 另外题面中的加大的字各位可以品尝..QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int s[2100][2100],n,q;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int y,int c)&#123; for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=n;j+=lowbit(j)) s[i][j]+=c;&#125;int query(int x,int y)&#123; int rtn=0; for(int i=x;i;i-=lowbit(i)) for(int j=y;j;j-=lowbit(j)) rtn+=s[i][j]; return rtn; &#125;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; scanf(\"%d%d\",&amp;n,&amp;q); memset(s,0,sizeof(s)); while(q--) &#123; char ch[5]; scanf(\"%s\",ch); if(ch[0]=='C') &#123; int x1,y1,x2,y2; scanf(\"%d%d%d%d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2); add(x2+1,y2+1,1); add(x1,y2+1,-1); add(x2+1,y1,-1); add(x1,y1,1); &#125; if(ch[0]=='Q') &#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",query(x,y)%2); &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; /*12 10C 2 1 2 2Q 2 2C 2 1 2 1Q 1 1C 1 1 2 1C 1 2 1 2C 1 1 2 2Q 1 1C 1 1 2 1Q 2 1*/","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://dextertyw.github.io/tags/树状数组/"},{"name":"数据结构","slug":"数据结构","permalink":"https://dextertyw.github.io/tags/数据结构/"},{"name":"二维","slug":"二维","permalink":"https://dextertyw.github.io/tags/二维/"}]},{"title":"noip模拟赛2017.7.22","slug":"[noip模拟赛2017.7.22]","date":"2017-07-23T06:10:22.003Z","updated":"2017-07-24T12:00:36.839Z","comments":true,"path":"2017/07/23/[noip模拟赛2017.7.22]/","link":"","permalink":"https://dextertyw.github.io/2017/07/23/[noip模拟赛2017.7.22]/","excerpt":"【试题概览】 题目名称 数7 正方形计数 速算游戏 单人纸牌 提交文件 seven.* count.* fun.* double.* 输入文件 seven.in count.in fun.in double.in 输出文件 seven.out count.out fun.out double.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB","text":"【试题概览】 题目名称 数7 正方形计数 速算游戏 单人纸牌 提交文件 seven.* count.* fun.* double.* 输入文件 seven.in count.in fun.in double.in 输出文件 seven.out count.out fun.out double.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB 1. 数7【题目描述】1337 个人排成一个圈，从 1 号人开始报数，初始的方向是 1,2,3…。如果某个人报的数是 7 的倍数或 者数字中含有 7，那么报数的方向就反一下。问报数字 X 的是哪个人？ 【输入格式】一行一个数 X 【输出格式】一行一个数表示最终报数字 X 的是哪个人。 【数据规模】对于 30%的数据，满足 X&lt;=10^6;对于 90%的数据，满足 X&lt;=10^8;对于 100%的数据，满足 X&lt;=10^9。 【输入样例】1000 【输出样例】1311 Solution首先都想到了nlogn的做法，再想直接打表，如果打表的话估计也只能过10^8 ,而且还不稳定。先想想90分怎么做，考虑到主要的时间消耗在于对%7的判断以及对是否含有7的判断，与其取膜和分解判断，倒不如用个计数器和做类似于高精度加法（每次只加一复杂都有保证）.然后对于10^9只能间隔打表了。 2.正方形计数【题目描述】给定平面上 N 个点，你需要计算以其中 4 个点为顶点的正方形的个数。注意这里的正方形边不一定 需要和坐标轴平行。 【输入格式】第一行一个数 N 以下 N 个点的坐标。 【输出格式】一个数，表示正方形的个数 【数据规模】对于 20%的数据，满足 1&lt;=N&lt;=20;对于 100%的数据，满足 1&lt;=N&lt;=500，-50&lt;=x[i],y[i]&lt;=50，点不会重叠。 【输入样例】7 0 0 0 1 1 0 1 1 1 2 2 1 2 2 Solution暴力枚举正方形的四个顶点判断边是否相等即可。或者枚举两个定点根据条件判断另外两个点是否存在。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct node&#123; int x,y; friend bool operator &lt; (node a,node b)&#123; if(a.x==b.x)return a.y&lt;b.y; return a.x&lt;b.x; &#125;&#125;point[550];int n,ans;int work(int x1,int y1,int x2,int y2)&#123; return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);&#125;int main()&#123; freopen(\"count.in\",\"r\",stdin); freopen(\"count.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;point[i].x,&amp;point[i].y); sort(point+1,point+1+n); for(int i=1;i&lt;=n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; int line_1=work(point[i].x,point[i].y,point[j].x,point[j].y); if(!line_1)continue; for(int k=j+1;k&lt;=n;k++) &#123; int line_2=work(point[i].x,point[i].y,point[k].x,point[k].y); if(line_1!=line_2)continue; for(int p=k+1;p&lt;=n;p++) &#123; int line_3=work(point[k].x,point[k].y,point[p].x,point[p].y); int line_4=work(point[p].x,point[p].y,point[j].x,point[j].y); int line_5=work(point[i].x,point[i].y,point[p].x,point[p].y); int line_6=work(point[j].x,point[j].y,point[k].x,point[k].y); if(line_2==line_3&amp;&amp;line_3==line_4&amp;&amp;line_5==line_6) ans++; &#125; &#125; &#125; &#125; printf(\"%d\",ans); return 0;&#125;/*70 00 11 01 11 22 12 2*/ 【输出样例】3 3.速算游戏【题目描述】jyx 和 cyy 打赌，比谁 24 点算得快，算得慢的那个人请客。24 点的规则是这样的：给定 4个 1..9 的整数，用括号改变运算顺序，通过加、减、乘、除通的一系列运算，得到整数 24，注意所有中间结果必须是整数（例如(22)/4 是允许的，而 2(2/4)是不允许的）。为了赢得这个比赛，请写一个程序帮助我作弊，快速地计算出 24 点。 【输入格式】一行 4 个整数，为给定的 4 个数字。输入数据保证有解。 【输出格式】一行，以字符串的形式输出结果，注意将每一步的运算的括号补齐（例如(3+5)+6 和3*(5+6)）如果有多种解答，输出字典顺序最小的一个。 【输入样例】2357 【输出样例】(((3*5)+2)+7) Solution被括号给骗了 感觉这道题挺蛮麻烦的，时只有3.5小时,所幸没有做，后来题时，真是傻逼题。太弱了…..括号在这题里只会有三种情况，自己想一想，然后依次写三个暴力就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define INF -2147483647using namespace std;int n[5],now[10],vis[10],r[50];int num[50][5];int cnt,tot;char ans[50][100];char trs(int x)&#123; if(x==1)return '+'; if(x==2)return '-'; if(x==3)return '*'; if(x==4)return '/';&#125;void Dfs_Pai(int pos)&#123; if(pos==5) &#123; cnt++; for(int i=1;i&lt;=4;i++) num[cnt][i]=now[i]; &#125; for(int i=1;i&lt;=4;i++) &#123; if(!vis[i]) &#123; now[pos]=n[i]; vis[i]=true; Dfs_Pai(pos+1); vis[i]=false; &#125; &#125;&#125;int calu(int a,int b,int opt)&#123; if(opt==1)return a+b; if(opt==2)return a-b; if(opt==3)return a*b; if(opt==4&amp;&amp;b!=0&amp;&amp;a%b==0)return a/b; return -INF;&#125;void Dfs_Judge(int p)&#123; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][1],num[p][2],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(result_1,num[p][3],j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(result_2,num[p][4],k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]='('; ans[tot][2]='('; ans[tot][3]=num[p][1]+'0'; ans[tot][4]=trs(i); ans[tot][5]=num[p][2]+'0'; ans[tot][6]=')'; ans[tot][7]=trs(j); ans[tot][8]=num[p][3]+'0'; ans[tot][9]=')'; ans[tot][10]=trs(k); ans[tot][11]=num[p][4]+'0'; ans[tot][12]=')'; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][1],num[p][2],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(num[p][3],num[p][4],j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(result_1,result_2,k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]='('; ans[tot][2]=num[p][1]+'0'; ans[tot][3]=trs(i); ans[tot][4]=num[p][2]+'0'; ans[tot][5]=')'; ans[tot][6]=trs(k); ans[tot][7]='('; ans[tot][8]=num[p][3]+'0'; ans[tot][9]=trs(j); ans[tot][10]=num[p][4]+'0'; ans[tot][11]=')'; ans[tot][12]=')'; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=4;i++) &#123; int result_1=calu(num[p][3],num[p][4],i); if(result_1==-INF)continue; for(int j=1;j&lt;=4;j++) &#123; int result_2=calu(num[p][2],result_1,j); if(result_2==-INF)continue; for(int k=1;k&lt;=4;k++) &#123; int result=calu(num[p][1],result_2,k); if(result==24) &#123; tot++; ans[tot][0]='('; ans[tot][1]=num[p][1]+'0'; ans[tot][2]=trs(k); ans[tot][3]='('; ans[tot][4]=num[p][2]+'0'; ans[tot][5]=trs(j); ans[tot][6]='('; ans[tot][7]=num[p][3]+'0'; ans[tot][8]=trs(i); ans[tot][9]=num[p][4]+'0'; ans[tot][10]=')'; ans[tot][11]=')'; ans[tot][12]=')'; &#125; &#125; &#125; &#125;&#125;bool cmp(int x,int y)&#123; for(int i=1;i&lt;=13;i++) &#123; if(ans[x][i]==ans[y][i])continue; return ans[x][i]&lt;ans[y][i]; &#125;&#125;int main()&#123; freopen(\"fun.in\",\"r\",stdin); freopen(\"fun.out\",\"w\",stdout); scanf(\"%d%d%d%d\",&amp;n[1],&amp;n[2],&amp;n[3],&amp;n[4]); Dfs_Pai(1); for(int i=1;i&lt;=cnt;i++) Dfs_Judge(i); for(int i=1;i&lt;=tot;i++) r[i]=i; sort(r+1,r+1+tot,cmp); printf(\"%s\",ans[r[1]]); return 0;&#125; /*2 3 5 7*/ 4.单人纸牌【题目描述】单人纸牌游戏，共 36 张牌分成 9 叠，每叠 4 张牌面向上。每次，游戏者可以从某两个不同的牌堆最顶上取出两张牌面相同的牌（如黑桃 10 和梅花 10）并且一起拿走。如果最后所有纸牌都被取走，则游戏者就赢了，否则游戏者就输了。George 很热衷于玩这个游戏，但是一旦有时有多种选择的方法，George 就不知道取哪一种好了，George 会从中随机地选择一种走，例如：顶上的 9 张牌为 KS,KH,KD,9H,8S,8D,7C,7D，6H，显然有 5 种取法： (KS,KH),(KS,KD),(KH,KD),(8S,8D),(7C,7D)，当然 George 取到每一种取法的概率都是 1/5。有一次，George 的朋友 Andrew 告诉他，这样做是很愚蠢的，不过 George 不相信，他认为如此玩最后成功的概率是非常大的。请写一个程序帮助 George 证明他的结论：计算按照他的策略，最后胜利的概率。 【输入格式】9 行每行 4 组用空格分开的字串，每个字串两个字符，分别表示牌面和花色，按照从堆底到堆顶的顺序给出。 【输出格式】一行，最后胜利的概率，精确到小数点后 6 位。 【输入样例】AS 9S 6C KS JC QH AC KH 7S QD JD KD QS TS JS 9H 6D TD AD 8S QC TH KC 8D 8C 9D TC 7C 9C 7H JH 7D8H 6S AH 6H 【输出样例】0.589314 Solution记忆化搜索轻松搞定，其实比较裸吧。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;char ch[10][5];bool f[5][5][5][5][5][5][5][5][5];double dp[5][5][5][5][5][5][5][5][5];double dfs(int c1,int c2,int c3,int c4,int c5,int c6,int c7,int c8,int c9)&#123; if(f[c1][c2][c3][c4][c5][c6][c7][c8][c9]) return dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]; f[c1][c2][c3][c4][c5][c6][c7][c8][c9]=true; int c[10]; c[1]=c1;c[2]=c2;c[3]=c3;c[4]=c4; c[5]=c5;c[6]=c6;c[7]=c7;c[8]=c8;c[9]=c9; int sum=0; for(int i=1;i&lt;=9;i++) for(int j=i+1;j&lt;=9;j++) &#123; if(ch[i][c[i]]==ch[j][c[j]]&amp;&amp;(c[i]&gt;0)&amp;&amp;(c[j]&gt;0)) &#123; sum++; c[i]--;c[j]--; dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]+=dfs(c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9]); c[i]++;c[j]++; &#125; &#125; if(sum!=0) dp[c1][c2][c3][c4][c5][c6][c7][c8][c9]/=sum; return dp[c1][c2][c3][c4][c5][c6][c7][c8][c9];&#125;int main()&#123; freopen(\"double.in\",\"r\",stdin); freopen(\"double.out\",\"w\",stdout); for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=4;j++) &#123; char a,b; cin&gt;&gt;a&gt;&gt;b; ch[i][j]=a; &#125; f[0][0][0][0][0][0][0][0][0]=1; dp[0][0][0][0][0][0][0][0][0]=1; dp[4][4][4][4][4][4][4][4][4]=dfs(4,4,4,4,4,4,4,4,4); printf(\"%.6f\",dp[4][4][4][4][4][4][4][4][4]); return 0;&#125;/*AS 9S 6C KSJC QH AC KH7S QD JD KDQS TS JS 9H6D TD AD 8SQC TH KC 8D8C 9D TC 7C9C 7H JH 7D8H 6S AH 6H*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://dextertyw.github.io/tags/记忆化搜索/"}]},{"title":"noip模拟赛2017.7.20","slug":"[noip模拟赛2017.7.20]","date":"2017-07-20T07:01:57.632Z","updated":"2017-07-24T11:59:40.472Z","comments":true,"path":"2017/07/20/[noip模拟赛2017.7.20]/","link":"","permalink":"https://dextertyw.github.io/2017/07/20/[noip模拟赛2017.7.20]/","excerpt":"题目名称 产品排序 分球 地图 数页码 提交文件 sort.* ball.* map.* count.* 输入文件 sort.in ball.in map.in count.in 输出文件 sort.out ball.out map.out count.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 32MB 题目来源 vijos vijos 模拟题 模拟题","text":"题目名称 产品排序 分球 地图 数页码 提交文件 sort.* ball.* map.* count.* 输入文件 sort.in ball.in map.in count.in 输出文件 sort.out ball.out map.out count.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 32MB 题目来源 vijos vijos 模拟题 模拟题 产品排序题目描述有一系列产品，给定每个产品的加工时间和冷却成型时间（冷却过程产品之间没有关系，是单独 冷却的）。现在你手上有两台机器可以用来加工，你需要安排产品加工的顺序以及去哪台机器加工， 使得所有产品都成型的时间最早。机器之间互不相关，可以同时进行工作，一个机器一个时刻只能加 工一个产品。 输入格式第一行一个数 n，表示产品个数，以下 n 行，每行两个数分别表示产品的加工时间 A[i]和冷却时间 B[i]。 输出格式一个数，表示所有产品成型的最早时间。 数据规模对于 20%的数据，满足 n&lt;=6;对于 100%的数据，满足 n,A[i],B[i]&lt;=200。 输入样例3 14 33 41 输出样例6 题解对于一个机器的情况，我们贪心处理，按冷却时间降序排序一定是最优的(因为冷却时间长的肯定先加工嘛)然后考虑两个机器的情况，因为所有产品都是要加工的，所以两个机器加工的总时间一定，那么我们可以动规处理，dp[i][j]表示加工前i件产品，其中第一个机器加工时长为j的时候，最少什么时候加工完成，如此说来，状态转移方程就好写了如果用第一台机器加工，那么就是 如果用第二台机器加工，那么就是 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF (1&lt;&lt;30)using namespace std;int dp[202][40400];struct node&#123; int t1,t2;&#125;a[202];bool cmp(node x,node y)&#123; return x.t2&gt;y.t2;&#125;int sum[202];int main()&#123; freopen(\"sort.in\",\"r\",stdin); freopen(\"sort.out\",\"w\",stdout); int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i].t1,&amp;a[i].t2); sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]+a[i].t1; for(int ta=0;ta&lt;=sum[i];ta++)&#123; int tb=sum[i]-ta; dp[i][ta]=INF; if(ta&gt;=a[i].t1) dp[i][ta]=min(dp[i][ta],max(ta+a[i].t2,dp[i-1][ta-a[i].t1])); if(tb&gt;=a[i].t1) dp[i][ta]=min(dp[i][ta],max(tb+a[i].t2,dp[i-1][ta])); &#125; &#125; int ans=INF; for(int ta=0;ta&lt;=sum[n];ta++) ans=min(dp[n][ta],ans); printf(\"%d\",ans);&#125; 分球题目描述有 N 个标号的球分到 M 个无差别的盒子里，每个盒子至少有一个球，问方案数。 输入格式多组数据；每部分一行两个数 N、M。 输出格式每组数据输出一行，一个数，表示方案数。 数据规模对于 20%的数据，满足 1&lt;=N，M&lt;=10;对于 100%的数据，满足 1&lt;=N，M&lt;=100，数组组数&lt;=10。 输入样例42 11 输出样例7 1 样例解释N=4,M=21,234 ；2,134；3,124；4,123；12,34；13,24；14,23 题解高精度DP，待填坑 地图题目描述给定一张地图，定义 X 表示陆地，O 表示海洋。两个格子连通，当且仅当它们共边。一个大陆定 义是一个极大的陆地连通块。极大的连通块的定义是不存在一个格子与当前连通块中的某个格子相连 但不属于当前连通块。问地图中有几个大陆。 输入格式第一行两个数 N，M，表示地图的大小，以下 N 行，每行 M 个字母。 输出格式一个数，表示大陆个数。 数据规模对于 30%的数据，满足 1&lt;=N，M&lt;=50。对于 100%的数据，满足 1&lt;=N，M&lt;=1000。 输入样例5 5XXXOOOOXOOOOOXXXOOOOXOXXX 输出样例4 题解简单的搜索12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF (1&lt;&lt;30)#define LL long longusing namespace std;bool mp[2000][2000];int m,n,ans;char s[2000];int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;void dfs(int x,int y)&#123; mp[x][y]=true; for(int i=0;i&lt;4;i++)&#123; int xx=x+dx[i],yy=y+dy[i]; if(!mp[xx][yy]) dfs(xx,yy); &#125;&#125;int main()&#123; freopen(\"map.in\",\"r\",stdin); freopen(\"map.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",s+1); for(int j=1;j&lt;=m;j++) if(s[j]=='O') mp[i][j]=true; &#125; for(int i=1;i&lt;=n;i++) mp[i][0]=mp[i][m+1]=true; for(int j=1;j&lt;=m;j++) mp[0][j]=mp[n+1][j]=true; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(!mp[i][j])&#123; dfs(i,j); ans++; &#125; printf(\"%d\",ans);&#125;/*5 5XXXOOOOXOOOOOXXXOOOOXOXXX*/ 数页码题目描述一本书的页码是从 1-n 编号的连续整数：1，2，3…，n。请你求出全部页码中所有单个数字的 和，例如第 123 页，它的和就是 1+2+3=6。 输入格式一行为 n(1&lt;=n&lt;=10^9)。 输出格式一行，代表所有单个数字的和。 输入样例3456789 输出样例96342015 题解可以考虑分位处理，先统计个位上出现的，再算十位…以此类推。但是要注意不要忘了每个位置剩下的，因为由于每个位的数字不相同，所以可能…这个只能意会吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int c[10],n;long long ans;int Get_Num(int x)&#123; int rtn=0; while(x) &#123; x/=10; rtn++; &#125; return rtn;&#125;int main()&#123; freopen(\"count.in\",\"r\",stdin); freopen(\"count.out\",\"w\",stdout); scanf(\"%d\",&amp;n); int num=Get_Num(n); int pow=1; for(int j=1;j&lt;=num;j++) &#123; pow*=10; int Pre_Number=n/pow*pow; int Bac_Number=n-Pre_Number; for(int i=1;i&lt;=9;i++) c[i]+=Pre_Number/10; int Re_Number=Bac_Number*10/pow; for(int i=1;i&lt;Re_Number;i++) c[i]+=pow/10; c[Re_Number]+=Bac_Number-Re_Number*(pow/10)+1; &#125; for(int i=1;i&lt;=9;i++) ans+=c[i]*i; printf(\"%d\\n\",ans);&#125;/*31 43 34 1*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"dp","slug":"dp","permalink":"https://dextertyw.github.io/tags/dp/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"}]},{"title":"manacher练习题","slug":"回文检测","date":"2017-07-19T13:39:50.356Z","updated":"2017-07-24T12:01:05.870Z","comments":true,"path":"2017/07/19/回文检测/","link":"","permalink":"https://dextertyw.github.io/2017/07/19/回文检测/","excerpt":"回文检测做这道题的目的为了联系一下Manacher，也会专门再写一篇Manacher的专题题目描述据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母’A’-‘Z’和’a’-‘z’。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。","text":"回文检测做这道题的目的为了联系一下Manacher，也会专门再写一篇Manacher的专题题目描述据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母’A’-‘Z’和’a’-‘z’。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。 输入输出格式输入格式： 输入文件不会超过20,000字符。这个文件可能一行或多行，但是每行都不超过80个字符(不包括最后的换行符)。 输出格式： 输出的第一行应该包括找到的最长的回文的长度。下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。如果有多个回文长度都等于最大值，输出最前面出现的那一个。 输入输出样例输入样例#1：\\Confucius say: Madam, I’m Adam.\\输出样例#1：\\11Madam, I’m Adam 说明题目翻译来自NOCOW。\\USACO Training Section 1.3 题解这道题可能是Manacher的模板题吧，我总觉得马拉车这个名字很蠢….以前还真的是以为和马有关系，知道真相的我….. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;char ch[30010],c[50010];int p[50010],trs[50010],ans=-1,Left,Right,cnt,cht,tmp=-1;void check(int pos)&#123; if(p[pos]&gt;tmp) &#123; tmp=p[pos]; ans=p[pos]-1; Left=pos-p[pos]+1,Right=pos+p[pos]-1; if(c[Left]=='#')Left++,Right--; &#125;&#125;void Manacher()&#123; int MaxRight=0,pos=0; for(int i=1;i&lt;=cnt;i++)&#123; int j=2*pos-i; if(i&lt;MaxRight)&#123; p[i]=min(MaxRight-i+1,p[j]); check(i); &#125; else&#123; int ll=i,rr=i; while(ll-1&gt;=0&amp;&amp;rr+1&lt;=cnt+1) &#123; if(c[ll]==c[rr])&#123; ll--;rr++;p[i]++; &#125; else break; &#125; check(i); pos=i,MaxRight=p[i]+pos-1; &#125; &#125;&#125;int main()&#123;#ifdef YSW freopen(\"in.txt\",\"r\",stdin);#endif char cc; c[cnt]='$';c[++cnt]='#'; while((cc=getchar())!=EOF) &#123; ch[++cht]=cc; if(ch[cht]&gt;='a'&amp;&amp;ch[cht]&lt;='z') c[++cnt]=ch[cht],trs[cnt]=cht,c[++cnt]='#';; if(ch[cht]&gt;='A'&amp;&amp;ch[cht]&lt;='Z') c[++cnt]=ch[cht]-'A'+'a',trs[cnt]=cht,c[++cnt]='#'; &#125; Manacher(); int l=trs[Left],r=trs[Right]; printf(\"%d\\n\",ans); for(int i=l;i&lt;=r;i++) printf(\"%c\",ch[i]); return 0;&#125;","categories":[],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"https://dextertyw.github.io/tags/Manacher/"}]},{"title":"noip模拟赛2017.7.11","slug":"[noip模拟赛2017.7.11]","date":"2017-07-19T13:39:45.993Z","updated":"2017-07-24T12:19:42.770Z","comments":true,"path":"2017/07/19/[noip模拟赛2017.7.11]/","link":"","permalink":"https://dextertyw.github.io/2017/07/19/[noip模拟赛2017.7.11]/","excerpt":"模拟试题(三)【试题概览】 题目名称 中位数 敲砖块 单词 邮递员送信 提交文件 median.* brike.* words.* post.* 输入文件 median.in brike.in words.in post.in 输出文件 median.out brike.out words.out post.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB","text":"模拟试题(三)【试题概览】 题目名称 中位数 敲砖块 单词 邮递员送信 提交文件 median.* brike.* words.* post.* 输入文件 median.in brike.in words.in post.in 输出文件 median.out brike.out words.out post.out 时间限制 1s 1s 1s 1s 空间限制 128MB 128MB 128MB 128MB 中位数【题目描述】有一个长度为 N 的数列{A1,A2,…,AN}，这 N 个数字恰好是 1..N 的一个排列。你需要统计有多少个 子序列{Ai,Ai+1,…,Aj}满足：i&lt;=j 且 j-i+1 为奇数，序列的中位数为 B。例如{5,1,3}的中位数为 3。 【输入格式】第一行包含两个正整数 N 和 B。第二行包含 N 个整数，第 i 个整数为 Ai. 【输出格式】仅包含一个整数，为满足条件的子序列的个数。 【数据规模】对于 30%的数据，满足 N&lt;=100;对于 60%的数据，满足 N&lt;=1000;对于 100%的数据，满足 N&lt;=100000,1&lt;=B&lt;=N。 【输入样例】7 4 5 7 2 4 3 1 6 【输出样例】4 题解第一题想了一个比n^2小那么一点的方法，奈何忘记判断边界，直接gg（md还有20分）。8020.！&amp;￥#！正解直接用d[i]前缀和的形式统计i位置及以前比B大的数和比它小的数个数之差，然后如果在B位置后面存在一个位置j使d[j]==d[i],则说明在i~j这段区间中比B大的数与比B小的数相等，和一个合法区间。然后如何O(n)判断？就是桶排序的类似思想，打标记。1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,b,a[100010],gre[100010],les[100010],num[100010],flag[200010];int trs(int x)&#123;return x+100010;&#125;int main()&#123; freopen(&quot;median.in&quot;,&quot;r&quot;,stdin); freopen(&quot;median.out&quot;,&quot;w&quot;,stdout); int pos,ans=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;b); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; gre[i]=gre[i-1],les[i]=les[i-1]; if(a[i]&gt;b)gre[i]++; if(a[i]&lt;b)les[i]++; if(a[i]==b)pos=i; num[i]=gre[i]-les[i]; &#125; for(int i=0;i&lt;=pos;i++)flag[trs(num[i])]++; for(int i=pos;i&lt;=n;i++)ans+=flag[trs(num[i])]; cout&lt;&lt;ans; return 0;&#125;/*7 47 2 4 3 6 5 1*/ 敲砖块【题目描述】在一个凹槽中放置了 N 层砖块，最上面的一层有 N 块砖，从上到下每层依次减少一块砖。每块砖 都有一个分值，敲掉这块砖就能得到相应的分值，如图所示14 15 4 3 2333 33 76 22 13 1222 2331如果你想敲掉第 i 层的第 j 块砖的话，若 i=1，你可以直接敲掉它；若 i&gt;1，则你必须先敲掉第 i-1 层的第 j 和第 j+1 块砖。你现在可以敲掉最多 M 块砖，求得分最多能有多少。 【输入格式】第一行有两个正整数 N 和 M；接下来的 N 行，描述这 N 层砖块上的分值 A[i,j]，满足 0&lt;=A[i,j]&lt;=100。 【输出格式】仅一行，包含一个整数，为最大的得分。 【数据规模】对于 20%的数据，满足 1&lt;=N&lt;=10,1&lt;=M&lt;=30;对于 100%的数据，满足 1&lt;=N&lt;=50,1&lt;=M&lt;=500。 【输入样例】4 5 2 2 3 4 8 2 7 2 3 49 【输出样例】19 题解（xjb算法）幸亏今天的第二题苟住了，dp直接AC，但我想说一下cxy想的记忆化搜索（1.因为dp真的很烦，公式推错直接gg.2.记忆化搜索还比较好想）。我们每次只处理一列中的选择方案，假设敲i及其以上（其实i以上是必然会被敲）由于敲砖方式的限制，下一列的搜索是存在限制的，必须敲掉i-1块及以上，当然也可以敲下面的。既然这个清楚了就比较好完成代码了。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define N 51using namespace std;int n,m,flag[N][N][(N*(N+1)/2)],dp[N][N][(N*(N+1)/2)],mp[N][N],sum[N][N];int dfs(int lie,int p,int lft)&#123; int rtn=sum[lie][p]; if(flag[lie][p][lft])return dp[lie][p][lft]; flag[lie][p][lft]=1; if(2*lft&lt;(p*(p+1)))return dp[lie][p][lft]=-1; if(lft&lt;0)return dp[lie][p][lft]=-1; if(lie&gt;n)return dp[lie][p][lft]=0; if(lft==0)return dp[lie][p][lft]=0; for(int i=p;i&lt;=n-lie+1;i++) &#123; int now=sum[lie][i]; int k=dfs(lie+1,max(i-1,0),lft-i); if(k==-1)break; rtn=max(now+k,rtn); &#125; return dp[lie][p][lft]=rtn; &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n-i+1;j++) scanf(&quot;%d&quot;,&amp;mp[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) sum[i][j]=sum[i][j-1]+mp[j][i]; printf(&quot;%d&quot;,dfs(1,0,m)); return 0;&#125; 单词【题目描述】有 N 个单词和字符串 T，按字典顺序输出以字符串 T 为前缀的所有单词。 【输入格式】第一行包含一个正整数 N；接下来 N 行，每行一个单词，长度不超过 50；最后一行包含字符串 T。 【输出格式】按字典顺序升序输出答案。 【数据规模】对于 60%的数据，满足 1&lt;=N&lt;=1000;对于 100%的数据，满足 1&lt;=N&lt;=10000 且所有字符均为小写字母。 【输入样例】6 na no ki ki ka ku k 【输出样例】ka ki ki ku 题解 很烦，string果然还是不能被接受。不过今天通过这道题也学到了，如果我们不便对于一个二维数组进行排序，我们可以间接通过对其下标的排序来完成。不过这道题的小技巧在于我们可以把要匹配的前缀也加入排列，然后再加入一个前缀后+’z’+1的一个串来保证会被派到最后一个，通过一开始的下标记录，我们可以完成对排序后的数组经行O(n)查找。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int n,cnt,l[10010],bh[10010];char ch[10010][100]; bool cmp(int x,int y)&#123; int len=min(l[x],l[y]); for(int i=0;i&lt;=len-1;i++) &#123; if(ch[x][i]==ch[y][i])continue; return ch[x][i]&lt;ch[y][i]; &#125; return l[x]&lt;l[y];&#125;int main()&#123; freopen(&quot;words.in&quot;,&quot;r&quot;,stdin); freopen(&quot;words.out&quot;,&quot;w&quot;,stdout); int pos; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,ch[i]),l[i]=strlen(ch[i]),bh[i]=i; scanf(&quot;%s&quot;,ch[0]); l[0]=strlen(ch[0]),bh[0]=0; for(int i=0;i&lt;l[0];i++) ch[n+1][i]=ch[0][i]; ch[n+1][l[0]]=&apos;z&apos;+1,l[n+1]=l[0]+1,bh[n+1]=n+1; stable_sort(bh,bh+2+n,cmp); for(int i=0;i&lt;=n+1;i++)if(bh[i]==0)&#123;pos=i;break;&#125; for(int i=pos+1;i;i++)&#123; if(bh[i]==n+1)break; else printf(&quot;%s\\n&quot;,ch[bh[i]]); &#125; return 0;&#125;/*6nanokikikakuk*/ 邮递员送信【题目描述】有一个邮递员要送东西，邮局在结点 1。他总共要送 N-1 样东西，其目的地分别是 2-N。由于这个 城市的交通比较繁忙，因此所有的道路都是单行的，共有 M 条道路，通过每条道路需要一定的时间。 这个邮递员每次只能带一样东西。求送完这 N-1 样东西并且最终回到邮局最少需要多少时间。 【输入格式】第一行包含一个正整数 N 和 M；接下来有 M 行，每行三个正整数 U、V、W，表示该条道路为从 U 到 V 的，且通过这条道路需要 W 的时间。满足 1&lt;=U,V&lt;=N,1&lt;=W&lt;=100000，输入保证任意两点都能互相到达。 【输出格式】包含一个整数，为最少需要的时间 【数据规模】30%的数据，1&lt;=N&lt;=200;100%的数据，1&lt;=N&lt;=1000，1&lt;=M&lt;=10000. 【输入样例】注意：如果有这样的情况：（1109） （1102） （1101）以最小的 w=1 进行存储 5 10 2 3 5 1 5 5 3 5 6 1 2 8 1 3 8 5 3 4 4 1 8 4 5 3 3 5 6 5 4 2 【输出样例】83 题解题目真的很有病，明明说了边数不超过10000，结果来个80000的数据，也是没谁了。由于题目中的边是单向边，所以建个反向边跑一跑就完事了，代码写的丑是真的，后来改题的时候弄了半天，傻X出题人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long longusing namespace std;int n,m,cnt,p[1010],edge[1010][1010],vis[1010];LL dis[1010];struct node&#123; int a,b,w,nt;&#125;e[10010],t[10010];void add1(int x,int y,int w)&#123; cnt++; e[cnt].a=x,e[cnt].b=y,e[cnt].w=w; e[cnt].nt=p[x],p[x]=cnt;&#125;void add2(int x,int y,int w)&#123; cnt++; t[cnt].a=x,t[cnt].b=y,t[cnt].w=w; t[cnt].nt=p[x],p[x]=cnt;&#125;queue&lt;int&gt;q1,q2;void spfa1()&#123; for(int i=1;i&lt;=n;i++)dis[i]=1e15;dis[1]=0; q1.push(1);vis[1]=1; while(!q1.empty())&#123; int k=q1.front();q1.pop();vis[k]=0; for(int i=p[k];i;i=e[i].nt)&#123; int kk=e[i].b; if(dis[kk]&gt;dis[k]+e[i].w)&#123; dis[kk]=dis[k]+e[i].w; if(!vis[kk])&#123; vis[kk]=1; q1.push(kk); &#125; &#125; &#125; &#125;&#125;void spfa2()&#123; for(int i=1;i&lt;=n;i++)dis[i]=1e15;dis[1]=0; q2.push(1);vis[1]=1; while(!q2.empty())&#123; int k=q2.front();q2.pop();vis[k]=0; for(int i=p[k];i;i=t[i].nt)&#123; int kk=t[i].b; if(dis[kk]&gt;dis[k]+t[i].w)&#123; dis[kk]=dis[k]+t[i].w; if(!vis[kk])&#123; vis[kk]=1; q2.push(kk); &#125; &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;post.in&quot;,&quot;r&quot;,stdin); freopen(&quot;post.out&quot;,&quot;w&quot;,stdout); LL ans=0; memset(edge,63,sizeof(edge)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); edge[x][y]=min(edge[x][y],z); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(edge[i][j]&lt;=100000&amp;&amp;i!=j) add1(i,j,edge[i][j]); spfa1(); for(int i=2;i&lt;=n;i++) ans+=dis[i]; memset(p,0,sizeof(p)),cnt=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(edge[i][j]&lt;=100000&amp;&amp;i!=j) add2(j,i,edge[i][j]); spfa2(); for(int i=2;i&lt;=n;i++) ans+=dis[i]; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;/*5 102 3 51 5 53 5 61 2 81 3 85 3 44 1 84 5 33 5 6 5 4 2*/*/","categories":[],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"https://dextertyw.github.io/tags/模拟赛/"},{"name":"dp","slug":"dp","permalink":"https://dextertyw.github.io/tags/dp/"},{"name":"优秀","slug":"优秀","permalink":"https://dextertyw.github.io/tags/优秀/"}]}]}